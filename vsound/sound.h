//=======================================================================
//			Copyright XashXT Group 2007 ©
//			sound.h - sndlib main header
//=======================================================================

#ifndef SOUND_H
#define SOUND_H

#include <windows.h>
#include <dsound.h>
#include "basetypes.h"
#include "stdapi.h"
#include "stdref.h"
#include "basefiles.h"
#include "dllapi.h"
#include "mathlib.h"

#include "s_openal.h"

extern stdlib_api_t com;
extern vsound_imp_t	si;
extern byte *sndpool;

typedef struct
{
	int	rate;
	int	width;
	int	channels;
	int	samples;
} wavinfo_t;

typedef struct sfx_s
{
	string		name;
	bool		default_snd;
	bool		loaded;
	int		samples;
	int		rate;
	uint		format;
	uint		bufferNum;

	struct sfx_s	*nextHash;
} sfx_t;

typedef struct
{
	string		introName;
	string		loopName;
	bool		looping;
	file_t		*file;
	int		start;
	int		rate;
	uint		format;
	void		*vorbisFile;
} bg_track_t;

// A playSound will be generated by each call to S_StartSound.
// When the mixer reaches playSound->beginTime, the playSound will be
// assigned to a channel.
typedef struct playsound_s
{
	struct playsound_s	*prev, *next;
	sfx_t		*sfx;
	int		entnum;
	int		entchannel;
	bool		fixedPosition;	// Use position instead of fetching entity's origin
	vec3_t		position;		// Only use if fixedPosition is set
	float		volume;
	float		attenuation;
	int		beginTime;	// Begin at this time
} playSound_t;

typedef struct
{
	bool		streaming;
	sfx_t		*sfx;		// NULL if unused
	int		entnum;		// To allow overriding a specific sound
	int		entchannel;
	int		startTime;	// For overriding oldest sounds
	bool		loopsound;	// Looping sound
	int		loopnum;		// Looping entity number
	int		loopframe;	// For stopping looping sounds
	bool		fixedPosition;	// Use position instead of fetching entity's origin
	vec3_t		position;		// Only use if fixedPosition is set
	float		volume;
	float		distanceMult;
	uint		sourceNum;	// OpenAL source
} channel_t;

typedef struct
{
	vec3_t		position;
	vec3_t		velocity;
	float		orientation[6];
} listener_t;

typedef struct
{
	const char	*vendor_string;
	const char	*renderer_string;
	const char	*version_string;
	const char	*extensions_string;

	string		deviceList[4];
	const char	*defDevice;
	uint		device_count;
	uint		num_slots;
	uint		num_sends;

	bool		allow_3DMode;

	// 3d mode extension (eax or i3d) 
	int (*Set3DMode)( const guid_t*, uint, uint, void*, uint );
	int (*Get3DMode)( const guid_t*, uint, uint, void*, uint );
} alconfig_t;

typedef struct
{
	aldevice		*hDevice;
	alcontext		*hALC;

	bool		initialized;
	bool		active;
	uint		framecount;
	int		num_channels;
	int		clientnum;
} alstate_t;

extern alconfig_t al_config;
extern alstate_t  al_state;

#define Host_Error com.error

#define Z_Malloc( size )	Mem_Alloc( sndpool, size )

// cvars
extern cvar_t *s_initSound;
extern cvar_t *s_show;
extern cvar_t *s_alDevice;
extern cvar_t *s_allowExtensions;
extern cvar_t *s_soundfx;
extern cvar_t *s_ignoreALErrors;
extern cvar_t *s_masterVolume;
extern cvar_t *s_sfxVolume;
extern cvar_t *s_musicVolume;
extern cvar_t *s_minDistance;
extern cvar_t *s_maxDistance;
extern cvar_t *s_rolloffFactor;
extern cvar_t *s_dopplerFactor;
extern cvar_t *s_dopplerVelocity;


extern int s_rawend;
extern int s_soundtime;

void S_Init( void *hInst );
void S_Shutdown( void );

void S_Activate( bool active );
void S_SoundList_f( void );

// if origin is NULL, the sound will be dynamically sourced from the entity
void S_StartSound( const vec3_t origin, int entnum, int entchannel, sound_t sfx, float vol, float attn );
int S_StartLocalSound( const char *name );
void S_StartBackgroundTrack( const char *intro, const char *loop );
void S_StopBackgroundTrack( void );
sfx_t *S_GetSfxByHandle( sound_t handle );
bool S_LoadSound( sfx_t *sfx );
channel_t	*S_PickChannel( int entNum, int entChannel );

void S_StartStreaming( void );
void S_StreamBackgroundTrack( void );
void S_StopStreaming( void );

// cinematics and voice-over-network will send raw samples
void S_StreamRawSamples( int samples, int rate, int width, int channels, const byte *data );

// stop all sounds and the background track
void S_StopAllSounds( void );
void S_FreeSounds( void );

// all continuous looping sounds must be added before calling S_Update
bool S_AddLoopingSound( int entnum, sound_t handle, float volume, float attn );
void S_StopLoopingSound(int entityNum );

// recompute the reletive volumes for all running sounds
// reletive to the given entityNum / orientation
void S_Respatialize( int entityNum, const vec3_t origin, const vec3_t v_forward, const vec3_t v_left, const vec3_t v_up );

// let the sound system know where an entity currently is
void S_UpdateEntityPosition( int entityNum, const vec3_t origin );
void S_Update( int clientnum, const vec3_t pos, const vec3_t vel, const vec3_t at, const vec3_t up );
void S_DisableSounds( void );
void S_EnableSounds( void );
void S_BeginRegistration( void );
void S_EndRegistration( void );

// RegisterSound will allways return a valid sample, even if it
// has to create a placeholder.  This prevents continuous filesystem
// checks for missing files
sound_t S_RegisterSound( const char *sample );
void S_DisplayFreeMemory(void);
void S_ClearSoundBuffer( void );
void SNDDMA_Activate( void );
void S_UpdateBackgroundTrack( void );

#endif//SOUND_H