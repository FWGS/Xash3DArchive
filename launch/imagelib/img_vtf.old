//=======================================================================
//			Copyright XashXT Group 2008 ©
//			img_vtf.c - vtf format load & save
//=======================================================================

#include "imagelib.h"

// VTF->DXT conversion supply structures
typedef struct
{
	long	ofs;		// offset at start
	size_t	size;		// map size
} vlayer_t;

typedef struct
{
	vlayer_t	layers[512];	// max frames or layers
	int	numlayers;
} vmip_t;

typedef struct
{
	vmip_t	mips[512];	// max frames or layers	
	int	nummips;		// or cubemap counts
} vside_t;

typedef struct
{
	vside_t	sides[CB_FACECOUNT];// 6 cubemap sides and one envmap
	int	numSides;		// must be equal 1 or 7
} vtex_t;

pixformat_t Image_VTFFormat( vtf_format_t srcFormat )
{
	switch( srcFormat )
	{
	case VTF_UNKNOWN:
		return VTF_UNKNOWN;
	case VTF_DXT1:
	case VTF_DXT1_ONEBITALPHA:
		return PF_DXT1;
	case VTF_DXT3:
		return PF_DXT3;
	case VTF_DXT5:
		return PF_DXT5;
	case VTF_RGBA16161616F:
		return PF_ABGR_64F;
	case VTF_BGR888:
		return PF_BGR_24;
	case VTF_UVWQ8888:
		return PF_RGBA_32;
	case VTF_BGRA8888:
		return PF_BGRA_32;
	case VTF_UV88:
		return PF_LUMINANCE_ALPHA;
#if 0
	case VTF_RGBA8888:
		return PF_RGBA_32;
	case VTF_RGB888:
		return PF_RGB_24;
	case VTF_RGB565:
		return PF_RGB_16;
	case VTF_I8:
		return PF_LUMINANCE;
	case VTF_IA88:
		return PF_LUMINANCE_ALPHA;
	case VTF_P8:
		return PF_INDEXED_24;
	case VTF_ARGB8888:
		return PF_ARGB_32;
#endif
	default: return PF_UNKNOWN;
	}
} 

/*
================
Image_VTFCalcMipmapSize

stupid idea - last miplevel (1x1) put at begin of buffer
or DX8 format requries it, i'm don't know...
================
*/
size_t Image_VTFCalcLowResSize( vtf_t *hdr )
{
	size_t	buffsize = 0;
	int	w, h, format;

	format = Image_VTFFormat( LittleLong( hdr->lowResImageFormat ));

	// missing lowRes image for -1 value
	if( format != VTF_UNKNOWN )
	{
		w = hdr->lowResImageWidth;
		h = hdr->lowResImageHeight;
		buffsize = Image_DXTGetLinearSize( format, w, h, 1, 0 );
	}
	return buffsize;
}

size_t Image_VTFCalcMipmapSize( vtf_t *hdr, int mipNum ) 
{
	size_t	buffsize = 0;
	int	w, h, mipsize;

	w = max( 1, (hdr->width)>>mipNum);
	h = max( 1, (hdr->height)>>mipNum);
	mipsize = Image_DXTGetLinearSize( image.type, w, h, 1, 0 );
	return mipsize;
}

size_t Image_VTFCalcImageSize( vtf_t *hdr, bool oldformat ) 
{
	size_t	buffsize = 0;
	int	i, numSides = 1;

	if( image.flags & IMAGE_CUBEMAP ) numSides = (oldformat) ? 6 : CB_FACECOUNT;
	for( i = 0; i < image.num_mips; i++ )
		buffsize += Image_VTFCalcMipmapSize( hdr, i ) * image.num_layers * numSides;
	return buffsize;
}

/*
================
Image_VTFSwapBuffer

VTF: <format>
header:	vtf_t
lowResImage[lowResSize]
mipmaps
  layers (frames)
    sides

DDS: <format>
header:	dds_t
sides
  mipmaps
    layers 
================
*/
void Image_VTFSwapBuffer( vtf_t *hdr, const byte *input, size_t input_size, bool oldformat )
{
	int	numSides = (image.flags & IMAGE_CUBEMAP) ? oldformat ? 6 : CB_FACECOUNT : 1; 
	vtex_t	*texture = Mem_Alloc( Sys.imagepool, sizeof( vtex_t ));
	bool	ignore_mips = (image.cmd_flags & IL_IGNORE_MIPS); 
	uint	i, j, k, out_size = 0;
	byte	*src, *dst;

	// output size can't be more than input size
	image.tempbuffer = Mem_Realloc( Sys.imagepool, image.tempbuffer, input_size );
	src = (byte *)(input + input_size);
	texture->numSides = numSides;
	dst = image.tempbuffer;

	// build image representation table
	// NOTE: src = buffer + sizeof(vtf_t) + lowResSize;
	for( i = 0; i < image.num_mips; i++ )
	{
		for( j = 0; j < image.num_layers; j++ )
		{
			for( k = 0; k < numSides; k++ )
			{
				texture->sides[k].mips[i].layers[j].size = Image_VTFCalcMipmapSize( hdr, i );
				src -= texture->sides[k].mips[i].layers[j].size;
				texture->sides[k].mips[i].layers[j].ofs = src - input;
				texture->sides[k].mips[i].numlayers++;
				texture->sides[k].nummips++;
			}
		}		
	}

	// write to DXT buffer
	for( i = 0; i < texture->numSides; i++ )
	{
		vside_t *side = &texture->sides[i];
		if( !oldformat && texture->numSides > 1 && i == 0 )
			continue; // skip envmap if needed
		for( j = 0; j < side->nummips; j++ )
		{
			vmip_t	*mip = &side->mips[j];
			if( ignore_mips && j > 0 ) continue;
			for( k = 0; k < mip->numlayers; k++ )
			{
				vlayer_t	*layer = &mip->layers[k];
				Mem_Copy( dst, input + layer->ofs, layer->size );
				out_size += layer->size;
				dst += layer->size;
			}
		}
	}

	// copy swapped buffer back to the input file, because tempbuffer
	// too unreliable place for keep this data
	Mem_Copy((byte *)input, image.tempbuffer, out_size );
	if( ignore_mips ) image.num_mips = 1;
	if( texture ) Mem_Free( texture );
	image.size = out_size;		// merge out size
}

/*
=============
Image_LoadVTF
=============
*/
bool Image_LoadVTF( const char *name, const byte *buffer, size_t filesize )
{            
	vtf_t	vtf;
	byte	*fin;
	string	shortname;
	bool	oldformat = false;
	int	i, flags, vtfFormat;
	uint	hdrSize, resSize, lowResSize;

	fin = (byte *)buffer;
	Mem_Copy( &vtf, fin, sizeof( vtf ));
	hdrSize = LittleLong( vtf.hdr_size );

	if( LittleLong( vtf.ident ) != VTFHEADER ) return false; // it's not a dds file, just skip it
	FS_FileBase( name, shortname );

	// bounds check
	i = LittleLong( vtf.ver_major );
	if( i != VTF_VERSION )
	{
		MsgDev( D_ERROR, "Image_LoadVTF: %s has wrong ver (%i should be %i)\n", shortname, i, VTF_VERSION );
		return false;
	}

	i = LittleLong( vtf.ver_minor );
	if( i == VTF_SUBVERSION0 && vtf.hdr_size == 64 )
	{
		MsgDev( D_NOTE, "Image_LoadVTF: ver 7.0 from hl2 beta\n" ); 
		oldformat = true; // missing envmap for cubemap images
	}
	else if( i == VTF_SUBVERSION1 && vtf.hdr_size == 64 )
		MsgDev( D_NOTE, "Image_LoadVTF: ver 7.1 without HDR\n" );
	else if( i == VTF_SUBVERSION2 && vtf.hdr_size == sizeof( vtf_t ))
		MsgDev( D_NOTE, "Image_LoadVTF: ver 7.2 with HDR\n" );
	else
	{
		MsgDev( D_ERROR, "Image_LoadVTF: file (%s) has wrong subversion %i\n", shortname, i );
		return false;
	}

	image.width = LittleShort( vtf.width );
	image.height = LittleShort( vtf.height );
	if(!Image_ValidSize( name )) return false;

	// translate VF_flags into IMAGE_flags
	flags = LittleLong( vtf.flags );
	if((flags & VF_ONEBITALPHA) || (flags & VF_EIGHTBITALPHA))
		image.flags |= IMAGE_HAVE_ALPHA;
	if( flags & VF_ENVMAP ) image.flags |= IMAGE_CUBEMAP;

	vtfFormat = LittleLong( vtf.imageFormat );
	image.num_layers = LittleLong( vtf.num_frames );
	image.type = Image_VTFFormat( vtfFormat );
	image.num_mips = LittleLong( vtf.numMipLevels );

	if( image.type == PF_UNKNOWN )
	{
		MsgDev( D_ERROR, "Image_LoadVTF: file (%s) has unknown format %i\n", shortname, vtfFormat );
		return false;		
	}

	lowResSize = Image_VTFCalcLowResSize( &vtf);          
	resSize = Image_VTFCalcImageSize( &vtf, (i == 0));
	i = hdrSize + lowResSize + resSize;

	if( filesize != i )
	{
		MsgDev( D_ERROR, "Image_LoadVTF: %s have invalid size (%i, should be %i)\n", name, filesize, i );
		return false;
	}
	if( image.type == PF_RGBA_32 ) Msg("image PF_RGBA_32\n" );
	fin += hdrSize + lowResSize; // skip lowRes image
	image.size = resSize;

	// convert VTF to DXT
	Image_VTFSwapBuffer( &vtf, fin, resSize, oldformat );

	if( Image_ForceDecompress())
	{
		int	offset, numsides = 1;
		uint	target = 1;
		byte	*buf = fin;

		// if hardware loader is absent or image not power of two
		// or user want load current side from cubemap we run software decompressing
		if( image.flags & IMAGE_CUBEMAP ) numsides = 6;
		Image_SetPixelFormat( image.width, image.height, image.num_layers ); // setup
		image.size = image.ptr = 0;
		if( image.cmd_flags & IL_IGNORE_MIPS )
			image.cur_mips = 1;
		else image.cur_mips = image.num_mips;
		image.num_mips = 1; // defaulting to one mip

		for( i = 0, offset = 0; i < numsides; i++, buf += offset )
		{
			Image_SetPixelFormat( image.curwidth, image.curheight, image.curdepth );
			offset = image.SizeOfFile; // move pointer

			Image_DecompressDDS( buf, target + i );
		}
		// now we can change type to RGBA
		if( image.hint != IL_HINT_NO ) image.flags &= ~IMAGE_CUBEMAP; // side extracted
		image.type = PF_RGBA_32;
	}
	else
	{
		// vtf files will be uncompressed on a render. requires minimal of info for set this
		image.rgba = Mem_Alloc( Sys.imagepool, image.size );
		Mem_Copy( image.rgba, fin, image.size );
	}
	return true;
}