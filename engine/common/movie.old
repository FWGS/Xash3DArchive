//=======================================================================
//			Copyright XashXT Group 2010 ©
//	    movie.c - playing AVI files (based on original AVIKit code)
//=======================================================================

#include "common.h"
#include "client.h"
#include "byteorder.h"
#include <vfw.h> // video for windows

typedef struct
{
	bool		active;

	PAVIFILE		pfile;		// avi file pointer
	PAVISTREAM	video_stream;	// video stream pointer
	PGETFRAME		video_getframe;	// pointer to getframe object for video stream
	long		video_frames;	// total frames
	long		video_xres;	// video stream resolution
	long		video_yres;
	float		video_fps;	// video stream fps

	PAVISTREAM	audio_stream;	// audio stream pointer
	WAVEFORMAT	*audio_header;	// audio stream header
	long		audio_header_size;	// WAVEFORMAT is returned for PCM data; WAVEFORMATEX for others
	long		audio_codec;	// WAVE_FORMAT_PCM is oldstyle: anything else needs conversion
	long		audio_length;	// in converted samples
	long		audio_bytes_per_sample; // guess.

	// compressed audio specific data
	dword		cpa_blockalign;	// block size to read
	HACMSTREAM	cpa_conversion_stream;
	ACMSTREAMHEADER	cpa_conversion_header;
	byte		*cpa_srcbuffer;	// maintained buffer for raw data
	byte		*cpa_dstbuffer;

	dword		cpa_blocknum;	// current block
	dword		cpa_blockpos;	// read position in current block
	dword		cpa_blockoffset;	// corresponding offset in bytes in the output stream
} movie_state_t;

cvar_t			*vid_gamma;
static byte		vid_gammaTable[256];// movie gamma-correction

static movie_state_t	avi;

// Converts a compressed audio stream into uncompressed PCM.
bool AVI_ACMConvertAudio( movie_state_t *Avi )
{
	WAVEFORMATEX	dest_header, *sh, *dh;
	AVISTREAMINFO	stream_info;
	dword		dest_length;
	short		bits;

	ASSERT( Avi != NULL );

	// WMA codecs, both versions - they simply don't work.
	if( Avi->audio_header->wFormatTag == 0x160 || Avi->audio_header->wFormatTag == 0x161 )
	{
		MsgDev( D_ERROR, "ACM does not support this audio codec.\n" );
		return false;
	}

	// get audio stream info to work with
	AVIStreamInfo( Avi->audio_stream, &stream_info, sizeof( stream_info ));

	if( Avi->audio_header_size < sizeof( WAVEFORMATEX ))
	{
		MsgDev( D_ERROR, "ACM failed to open conversion stream.\n" );
		return false;
	}

	sh = (WAVEFORMATEX *)Avi->audio_header;
	bits = 16; // predict state

	// how much of this is actually required?
	dest_header.wFormatTag = WAVE_FORMAT_PCM; // yay
	dest_header.wBitsPerSample = bits; // 16bit
	dest_header.nChannels = sh->nChannels;
	dest_header.nSamplesPerSec = sh->nSamplesPerSec; // take straight from the source stream
	dest_header.nAvgBytesPerSec = (bits >> 3) * sh->nChannels * sh->nSamplesPerSec;
	dest_header.nBlockAlign = (bits >> 3) * sh->nChannels;
	dest_header.cbSize = 0; // no more data.

	dh = &dest_header;

	// open the stream
	if( acmStreamOpen( &Avi->cpa_conversion_stream, NULL, sh, dh, NULL, 0, 0, 0 ) != MMSYSERR_NOERROR )
	{
		// try with 8 bit destination instead
		bits = 8;

		dest_header.wBitsPerSample = bits; // 8bit
		dest_header.nAvgBytesPerSec = ( bits >> 3 ) * sh->nChannels * sh->nSamplesPerSec;
		dest_header.nBlockAlign = ( bits >> 3 ) * sh->nChannels; // 1 sample at a time

		if( acmStreamOpen( &Avi->cpa_conversion_stream, NULL, sh, dh, NULL, 0, 0, 0 ) != MMSYSERR_NOERROR )
		{
			MsgDev( D_ERROR, "ACM failed to open conversion stream.\n" );
			return false;
		}
	}

	Avi->cpa_blockalign = sh->nBlockAlign;
	dest_length = 0;

	// mp3 specific fix
	if( sh->wFormatTag == 0x55 )
	{
		LPMPEGLAYER3WAVEFORMAT	k;

		k = (LPMPEGLAYER3WAVEFORMAT)sh;
		Avi->cpa_blockalign = k->nBlockSize;
	}

	// get the size of the output buffer for streaming the compressed audio
	if( acmStreamSize( Avi->cpa_conversion_stream, Avi->cpa_blockalign, &dest_length, ACM_STREAMSIZEF_SOURCE ) != MMSYSERR_NOERROR )
	{
		MsgDev( D_ERROR, "Couldn't get ACM conversion stream size.\n" );
		acmStreamClose( Avi->cpa_conversion_stream, 0 );
		return false;
	}

	Avi->cpa_srcbuffer = (byte *)Mem_Alloc( cls.mempool, Avi->cpa_blockalign );
	Avi->cpa_dstbuffer = (byte *)Mem_Alloc( cls.mempool, dest_length ); // maintained buffer for raw data

	// prep the headers!
	Avi->cpa_conversion_header.cbStruct = sizeof( ACMSTREAMHEADER );
	Avi->cpa_conversion_header.fdwStatus = 0;
	Avi->cpa_conversion_header.dwUser = 0;				// no user data
	Avi->cpa_conversion_header.pbSrc = Avi->cpa_srcbuffer;		// source buffer
	Avi->cpa_conversion_header.cbSrcLength = Avi->cpa_blockalign;	// source buffer size
	Avi->cpa_conversion_header.cbSrcLengthUsed = 0;
	Avi->cpa_conversion_header.dwSrcUser = 0;			// no user data
	Avi->cpa_conversion_header.pbDst = Avi->cpa_dstbuffer;		// dest buffer
	Avi->cpa_conversion_header.cbDstLength = dest_length;		// dest buffer size
	Avi->cpa_conversion_header.cbDstLengthUsed = 0;
	Avi->cpa_conversion_header.dwDstUser = 0;			// no user data

	if( acmStreamPrepareHeader( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, 0 ) != MMSYSERR_NOERROR )
	{
		MsgDev( D_ERROR, "couldn't prep headers.\n" );
		acmStreamClose( Avi->cpa_conversion_stream, 0 );
		return false;
	}

	Avi->cpa_blocknum = 0; // start at 0.
	Avi->cpa_blockpos = 0;
	Avi->cpa_blockoffset = 0;

	AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
	acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN|ACM_STREAMCONVERTF_START );

	// convert first chunk twice. it often fails the first time. BLACK MAGIC.
	AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
	acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

	Avi->audio_bytes_per_sample = (bits >> 3 ) * Avi->audio_header->nChannels;

	return true;
}

bool AVI_GetVideoInfo( movie_state_t *Avi, long *xres, long *yres, float *duration )
{
	ASSERT( Avi != NULL );

	if( !Avi->active )
		return false;

	if( xres != NULL )
		*xres = Avi->video_xres;

	if( yres != NULL )
		*yres = Avi->video_yres;

	if( duration != NULL )
		*duration = (float)Avi->video_frames / Avi->video_fps;

	return true;
}

// returns a unique frame identifier
long AVI_GetVideoFrameNumber( movie_state_t *Avi, float time )
{
	ASSERT( Avi != NULL );

	if( !Avi->active )
		return 0;

	return (time * Avi->video_fps);
}

// gets the raw frame data
void AVI_GetVideoFrame( movie_state_t *Avi, byte *outbuffer, long frame )
{
	LPBITMAPINFOHEADER	image, frame_info;
	byte		palette[256][4], *pixbuf, *buf_p;
	int		i, columns, column, rows, row, bps;
	int		cbPalBytes = 0, padSize = 0;
	char		*frame_raw;
	char		*in, *out, *bufend;

	ASSERT( Avi != NULL );

	if( !Avi->active ) return;

	if( frame >= Avi->video_frames )
		frame = Avi->video_frames - 1;

	frame_info = image = (LPBITMAPINFOHEADER)AVIStreamGetFrame( Avi->video_getframe, frame );

	if( image->biSize != 0x28 )
	{
		MsgDev( D_ERROR, "AVI_GetVideoFrame: invalid header size %i\n", image->biSize );
		SCR_StopCinematic();
		return;
	}

	// bogus compression?  Only non-compressed supported.
	if( image->biCompression != BI_RGB ) 
	{
		MsgDev( D_ERROR, "AVI_GetVideoFrame: only uncompressed AVI frames supported\n" );
		SCR_StopCinematic();
		return;
	}

	columns = image->biWidth;
	rows = abs( image->biHeight );

	ASSERT( Avi->video_xres == image->biWidth );
	ASSERT( Avi->video_yres == image->biHeight );

	if( image->biBitCount <= 8 )
	{
		// figure out how many entires are actually in the table
		if( image->biClrUsed == 0 )
		{
			image->biClrUsed = 256;
			cbPalBytes = (1 << image->biBitCount) * sizeof( RGBQUAD );
		}
		else cbPalBytes = image->biClrUsed * sizeof( RGBQUAD );
	}

	// copy palette
	Mem_Copy( palette, frame_info + frame_info->biSize, cbPalBytes );
	buf_p = (byte *)frame_info + frame_info->biSize + cbPalBytes;
	bps = columns * (image->biBitCount >> 3);

	switch( image->biBitCount )
	{
	case 1:
		padSize = (( 32 - ( image->biWidth % 32 )) / 8 ) % 4;
		break;
	case 4:
		padSize = (( 8 - ( image->biWidth % 8 )) / 2 ) % 4;
		break;
	case 16:
		padSize = ( 4 - ( image->biWidth * 2 % 4 )) % 4;
		break;
	case 8:
	case 24:
		padSize = ( 4 - ( bps % 4 )) % 4;
		break;
	}

	for( row = rows - 1; row >= 0; row-- )
	{
		pixbuf = outbuffer + (row * columns * 3);

		for( column = 0; column < columns; column++ )
		{
			byte	red, green, blue, alpha;
			word	shortPixel;
			int	c, k, palIndex;

			switch( image->biBitCount )
			{
			case 1:
				alpha = *buf_p++;
				column--;	// ingnore main iterations
				for( c = 0, k = 128; c < 8; c++, k >>= 1 )
				{
					red = (!!(alpha & k) == 1 ? 0xFF : 0x00);
					*pixbuf++ = vid_gammaTable[red];
					*pixbuf++ = vid_gammaTable[red];
					*pixbuf++ = vid_gammaTable[red];
					if( ++column == columns )
						break;
				}
				break;
			case 4:
				alpha = *buf_p++;
				palIndex = alpha >> 4;
				*pixbuf++ = vid_gammaTable[palette[palIndex][2]];
				*pixbuf++ = vid_gammaTable[palette[palIndex][1]];
				*pixbuf++ = vid_gammaTable[palette[palIndex][0]];
				if( ++column == columns ) break;
				palIndex = alpha & 0x0F;
				*pixbuf++ = vid_gammaTable[palette[palIndex][2]];
				*pixbuf++ = vid_gammaTable[palette[palIndex][1]];
				*pixbuf++ = vid_gammaTable[palette[palIndex][0]];
				break;
			case 8:
				palIndex = *buf_p++;
				red = palette[palIndex][2];
				green = palette[palIndex][1];
				blue = palette[palIndex][0];
				alpha = palette[palIndex][3];
				*pixbuf++ = vid_gammaTable[red];
				*pixbuf++ = vid_gammaTable[green];
				*pixbuf++ = vid_gammaTable[blue];
				break;
			case 16:
				shortPixel = *(word *)buf_p, buf_p += 2;
				*pixbuf++ = vid_gammaTable[(shortPixel & ( 31 << 10 )) >> 7];
				*pixbuf++ = vid_gammaTable[(shortPixel & ( 31 << 5 )) >> 2];
				*pixbuf++ = vid_gammaTable[(shortPixel & ( 31 )) << 3];
				break;
			case 24:
				blue = *buf_p++;
				green = *buf_p++;
				red = *buf_p++;
				*pixbuf++ = vid_gammaTable[red];
				*pixbuf++ = vid_gammaTable[green];
				*pixbuf++ = vid_gammaTable[blue];
				break;
			case 32:
				blue = *buf_p++;
				green = *buf_p++;
				red = *buf_p++;
				alpha = *buf_p++;
				*pixbuf++ = vid_gammaTable[red];
				*pixbuf++ = vid_gammaTable[green];
				*pixbuf++ = vid_gammaTable[blue];
				break;
			default:
				MsgDev( D_ERROR, "AVI_GetVideoFrame: illegal pixel size\n" );
				SCR_StopCinematic();
				return;
			}
		}
		buf_p += padSize;	// actual only for 4-bit bmps
	}
	return;



	frame_raw = (char *)frame_info + frame_info->biSize + frame_info->biClrUsed * sizeof( RGBQUAD );
	out = outbuffer;

	// convert BGR to RGB and flip upside down
	for( i = Avi->video_yres - 1; i >= 0; i-- )
	{
		in = frame_raw + i * Avi->video_xres * 3;
		bufend = in + Avi->video_xres * 3;
		for ( ; in < bufend; in += 3 )
		{
			*out++ = (char)vid_gammaTable[(byte)in[2]];
			*out++ = (char)vid_gammaTable[(byte)in[1]];
			*out++ = (char)vid_gammaTable[(byte)in[0]];
		}
	}
}

bool AVI_GetAudioInfo( movie_state_t *Avi, wavdata_t *snd_info )
{
	ASSERT( Avi != NULL );

	if( !Avi->active || Avi->audio_stream == NULL || snd_info == NULL )
	{
		return false;
	}

	snd_info->rate = Avi->audio_header->nSamplesPerSec;
	snd_info->channels = Avi->audio_header->nChannels;

	if( Avi->audio_codec == WAVE_FORMAT_PCM ) // uncompressed audio!
		snd_info->width = ( Avi->audio_bytes_per_sample > Avi->audio_header->nChannels ) ? 2 : 1;
	else snd_info->width = 2; // assume compressed audio is always 16 bit

	snd_info->size = snd_info->rate * snd_info->width * snd_info->channels;
	snd_info->loopStart = 0;	// HACKHACK: use loopStart as streampos

	return true;
}

// sync the current audio read to a specific offset
bool AVI_SeekPosition( movie_state_t *Avi, dword offset )
{
	int	breaker;

	ASSERT( Avi != NULL );

	if( offset < Avi->cpa_blockoffset ) // well, shit. we can't seek backwards... restart
	{
		if( Avi->cpa_blockoffset - offset < 500000 )
			return false; // don't bother if it's gonna catch up soon (cheap hack! works!)

		Avi->cpa_blocknum = 0; // start at 0, eh.
		Avi->cpa_blockpos = 0;
		Avi->cpa_blockoffset = 0;

		AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
		acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN|ACM_STREAMCONVERTF_START );

		// convert first chunk twice. it often fails the first time. BLACK MAGIC.
		AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
		acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );
	}

	// now then: seek forwards to the required block
	breaker = 30; // maximum zero blocks: anti-freeze protection

	while( Avi->cpa_blockoffset + Avi->cpa_conversion_header.cbDstLengthUsed < offset )
	{
		Avi->cpa_blocknum++;
		Avi->cpa_blockoffset += Avi->cpa_conversion_header.cbDstLengthUsed;

		AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
		acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

		if( Avi->cpa_conversion_header.cbDstLengthUsed == 0 )
			breaker--;
		else breaker = 30;

		if( breaker <= 0 )
			return false;

		Avi->cpa_blockpos = 0;
	}

	// seek to the right position inside the block
	Avi->cpa_blockpos = offset - Avi->cpa_blockoffset;

	return true;
}

// get a chunk of audio from the stream (in bytes)
fs_offset_t AVI_GetAudioChunk( movie_state_t *Avi, char *audiodata, long offset, long length )
{
	int	i;
	long	result = 0;

	ASSERT( Avi != NULL );

	// zero data past the end of the file
	if( offset + length > Avi->audio_length )
	{
		if( offset <= Avi->audio_length )
		{
			long	remaining_length = Avi->audio_length - offset;

			AVI_GetAudioChunk( Avi, audiodata, offset, remaining_length );

			for( i = remaining_length; i < length; i++ )
				audiodata[i] = 0;
		}
		else
		{
			for( i = 0; i < length; i++ )
				audiodata[i] = 0;
		}
	}

	// uncompressed audio!
	if( Avi->audio_codec == WAVE_FORMAT_PCM )
	{
		// very simple - read straight out
		AVIStreamRead( Avi->audio_stream, offset / Avi->audio_bytes_per_sample, length / Avi->audio_bytes_per_sample, audiodata, length, &result, NULL );
		return result;
	}
	else
	{
		// compressed audio!
		result = 0;

		// seek to correct chunk and all that stuff
		if( !AVI_SeekPosition( Avi, offset )) 
			return 0; // don't continue if we're waiting for the play pointer to catch up

		while( length > 0 )
		{
			long	blockread = Avi->cpa_conversion_header.cbDstLengthUsed - Avi->cpa_blockpos;

			if( blockread <= 0 ) // read next
			{
				Avi->cpa_blocknum++;
				Avi->cpa_blockoffset += Avi->cpa_conversion_header.cbDstLengthUsed;

				AVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );
				acmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

				Avi->cpa_blockpos = 0;
				continue;
			}

			if( blockread > length )
				blockread = length;

			// copy the data
			Mem_Copy( audiodata + result, (void *)( Avi->cpa_dstbuffer + Avi->cpa_blockpos ), blockread );

			Avi->cpa_blockpos += blockread;
			result += blockread;
			length -= blockread;
		}
		return result;
	}
}

void AVI_CloseVideo( movie_state_t *Avi )
{
	ASSERT( Avi != NULL );

	if( Avi->active )
	{
		AVIStreamGetFrameClose( Avi->video_getframe );

		if( Avi->audio_stream != NULL )
		{
			AVIStreamRelease( Avi->audio_stream );
			Mem_Free( Avi->audio_header );

			if( Avi->audio_codec != WAVE_FORMAT_PCM )
			{
				acmStreamUnprepareHeader( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, 0 );
				acmStreamClose( Avi->cpa_conversion_stream, 0 );
				Mem_Free( Avi->cpa_srcbuffer );
				Mem_Free( Avi->cpa_dstbuffer );
			}
		}

		AVIStreamRelease( Avi->video_stream );
	}

	Mem_Set( Avi, 0, sizeof( movie_state_t ));
}

void AVI_OpenVideo( movie_state_t *Avi, const char *filename, bool load_audio )
{
	AVISTREAMINFO	stream_info;
	long		opened_streams = 0;
	LONG		hr;

	ASSERT( Avi != NULL );

	// default state: non-working.
	Avi->active = false;

	// load the AVI
	hr = AVIFileOpen( &Avi->pfile, filename, OF_SHARE_DENY_WRITE, 0L );

	if( hr != 0 ) // error opening AVI:
	{
		switch( hr )
		{
		case AVIERR_BADFORMAT:
			MsgDev( D_ERROR, "corrupt file or unknown format.\n" );
			break;
		case AVIERR_MEMORY:
			MsgDev( D_ERROR, "insufficient memory to open file.\n" );
			break;
		case AVIERR_FILEREAD:
			MsgDev( D_ERROR, "disk error reading file.\n" );
			break;
		case AVIERR_FILEOPEN:
			MsgDev( D_ERROR, "disk error opening file.\n" );
			break;
		case REGDB_E_CLASSNOTREG:
		default:
			MsgDev( D_ERROR, "no handler found (or file not found).\n" );
			break;
		}
		return;
	}

	Avi->video_stream = Avi->audio_stream = NULL;

	// open the streams until a stream is not available. 
	while( 1 )
	{
		PAVISTREAM	stream = NULL;

		if( AVIFileGetStream( Avi->pfile, &stream, 0L, opened_streams++ ) != AVIERR_OK )
			break;

		if( stream == NULL )
			break;

		AVIStreamInfo( stream, &stream_info, sizeof( stream_info ));

		if( stream_info.fccType == streamtypeVIDEO && Avi->video_stream == NULL )
		{
			Avi->video_stream = stream;
			Avi->video_frames = stream_info.dwLength;
			Avi->video_xres = stream_info.rcFrame.right - stream_info.rcFrame.left;
			Avi->video_yres = stream_info.rcFrame.bottom - stream_info.rcFrame.top;
			Avi->video_fps = (float)stream_info.dwRate / (float)stream_info.dwScale;
		}
		else if( stream_info.fccType == streamtypeAUDIO && Avi->audio_stream == NULL && load_audio )
		{
			long	size;

			Avi->audio_stream = stream;

			// read the audio header
			AVIStreamReadFormat( Avi->audio_stream, AVIStreamStart( Avi->audio_stream ), 0, &size );

			Avi->audio_header = (WAVEFORMAT *)Mem_Alloc( cls.mempool, size );
			AVIStreamReadFormat( Avi->audio_stream, AVIStreamStart( Avi->audio_stream ), Avi->audio_header, &size );
			Avi->audio_header_size = size;
			Avi->audio_codec = Avi->audio_header->wFormatTag;

			// length of converted audio in samples
			Avi->audio_length = (long)((float)stream_info.dwLength / Avi->audio_header->nAvgBytesPerSec );
			Avi->audio_length *= Avi->audio_header->nSamplesPerSec;

			if( Avi->audio_codec != WAVE_FORMAT_PCM )
			{
				if( !AVI_ACMConvertAudio( Avi ))
				{
					Mem_Free( Avi->audio_header );
					Avi->audio_stream = NULL;
					continue;
				}
			}
			else Avi->audio_bytes_per_sample = Avi->audio_header->nBlockAlign;
			Avi->audio_length *= Avi->audio_bytes_per_sample;
		} 
		else
		{
			AVIStreamRelease( stream );
		}
	}

	// display error message-stream not found. 
	if( Avi->video_stream == NULL )
	{
		if( Avi->pfile ) // If file is open, close it 
			AVIFileRelease( Avi->pfile );
		MsgDev( D_ERROR, "couldn't find a valid video stream.\n" );
		return;
	}

	AVIFileRelease( Avi->pfile ); // release the file

	Avi->video_getframe = AVIStreamGetFrameOpen( Avi->video_stream, NULL ); // open the frame getter

	if( Avi->video_getframe == NULL )
	{
		MsgDev( D_ERROR, "error attempting to read video frames.\n" );
		return; // couldn't open frame getter.
	}

	Avi->active = true; // done
}

/*
=================================================================

AVI PLAYING

=================================================================
*/

static long	xres, yres;
static float	video_duration;
static float	cin_time;
static int	cin_frame;
static byte	*cin_data;	// dynamically allocated array
static wavdata_t	cin_audio;

void SCR_RebuildGammaTable( void )
{
	float	g;
	int	i;

	g = bound( 0.5f, vid_gamma->value, 2.3f );

	// screenshots gamma	
	for( i = 0; i < 256; i++ )
	{
		if( g == 1 ) vid_gammaTable[i] = i;
		else vid_gammaTable[i] = bound( 0, pow( i * ( 1.0f / 255.0f ), g ) * 255.0f, 255 );
	}
}
		
/*
==================
SCR_RunCinematic
==================
*/
void SCR_RunCinematic( void )
{
	if( !avi.active ) return;

	if( vid_gamma->modified )
	{
		SCR_RebuildGammaTable();
		vid_gamma->modified = false;
	}

	// advances cinematic time	
	cin_time += cls.frametime;

	// stop the video after it finishes
	if( cin_time > video_duration + 0.1f )
	{
		SCR_StopCinematic();
		return;
	}

	// read the next frame
	cin_frame = AVI_GetVideoFrameNumber( &avi, cin_time );
}

/*
==================
SCR_DrawCinematic

Returns true if a cinematic is active, meaning the view rendering
should be skipped
==================
*/
bool SCR_DrawCinematic( void )
{
	static int	last_frame = -1;
	bool		redraw = false;

	if( !re || cin_time <= 0.0f )
		return false;

	if( cin_frame != last_frame )
	{
		AVI_GetVideoFrame( &avi, cin_data, cin_frame );
		last_frame = cin_frame;
		redraw = true;
	}

	re->DrawStretchRaw( 0, 0, scr_width->integer, scr_height->integer, xres, yres, cin_data, redraw );

	return true;
}
  
/*
==================
SCR_PlayCinematic
==================
*/
bool SCR_PlayCinematic( const char *arg )
{
	string		path;
	const char	*fullpath;

	com.snprintf( path, sizeof( path ), "media/%s.avi", arg );
	fullpath = FS_GetDiskPath( path );

	if( FS_FileExists( path ) && !fullpath )
	{
		MsgDev( D_ERROR, "couldn't load %s from packfile. Please extract it\n", path );
		return false;
	}

	AVI_OpenVideo( &avi, fullpath, true );
	if( !avi.active )
	{
		AVI_CloseVideo( &avi );
		return false;
	}

	if( !( AVI_GetVideoInfo( &avi, &xres, &yres, &video_duration ))) // couldn't open this at all.
	{
		AVI_CloseVideo( &avi );
		return false;
	}

	cin_data = Mem_Realloc( cls.mempool, cin_data, xres * yres * 3 );

	if( AVI_GetAudioInfo( &avi, &cin_audio ))
	{
		// begin streaming
		S_StopAllSounds();
		S_StartStreaming();
	}

	UI_SetActiveMenu( false );
	SCR_RebuildGammaTable();

	cls.state = ca_cinematic;
	cin_time = 0.0f;
	
	return true;
}

long SCR_GetAudioChunk( char *rawdata, long length )
{
	int	r;

	r = AVI_GetAudioChunk( &avi, rawdata, cin_audio.loopStart, length );
	cin_audio.loopStart += r;	// advance play position

	return r;
}

wavdata_t *SCR_GetMovieInfo( void )
{
	if( avi.active )
		return &cin_audio;
	return NULL;
}
	
/*
==================
SCR_StopCinematic
==================
*/
void SCR_StopCinematic( void )
{
	AVI_CloseVideo( &avi );

	cls.state = ca_disconnected;
	UI_SetActiveMenu( true );
	S_StopStreaming();
	cin_time = 0.0f;
}

/*
==================
SCR_InitCinematic
==================
*/
void SCR_InitCinematic( void )
{
	AVIFileInit();

	// used for movie gamma correction
	vid_gamma = Cvar_Get( "vid_gamma", "1.0", CVAR_ARCHIVE, "gamma amount" );
}

/*
==================
SCR_FreeCinematic
==================
*/
void SCR_FreeCinematic( void )
{
	AVIFileExit();
}