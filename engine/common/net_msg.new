//=======================================================================
//			Copyright XashXT Group 2007 ©
//			net_msg.c - network messages
//=======================================================================

#include "common.h"
#include "byteorder.h"
#include "mathlib.h"

// angles pack methods
#define ANGLE2CHAR(x)	((int)((x)*256 / 360) & 255)
#define CHAR2ANGLE(x)	((x)*(360.0f / 256))
#define ANGLE2SHORT(x)	((int)((x)*65536 / 360) & 65535)
#define SHORT2ANGLE(x)	((x)*(360.0f / 65536))

static net_field_t ent_fields[] =
{
{ ES_FIELD(ed_type),		NET_BYTE,	 false	},	// stateflags_t #0 (4 bytes)
{ ES_FIELD(ed_flags),		NET_BYTE,	 true	},	// stateflags_t #0 (4 bytes)
{ ES_FIELD(classname),		NET_WORD,  false	},
{ ES_FIELD(soundindex),		NET_WORD,	 false	},	// 512 sounds ( OpenAL software limit is 255 )
{ ES_FIELD(origin[0]),		NET_FLOAT, false	},
{ ES_FIELD(origin[1]),		NET_FLOAT, false	},
{ ES_FIELD(origin[2]),		NET_FLOAT, false	},
{ ES_FIELD(angles[0]),		NET_FLOAT, false	},
{ ES_FIELD(angles[1]),		NET_FLOAT, false	},
{ ES_FIELD(angles[2]),		NET_FLOAT, false	},
{ ES_FIELD(velocity[0]),		NET_FLOAT, false	},
{ ES_FIELD(velocity[1]),		NET_FLOAT, false	},
{ ES_FIELD(velocity[2]),		NET_FLOAT, false	},
{ ES_FIELD(avelocity[0]),		NET_FLOAT, false	},
{ ES_FIELD(avelocity[1]),		NET_FLOAT, false	},
{ ES_FIELD(avelocity[2]),		NET_FLOAT, false	},
{ ES_FIELD(modelindex),		NET_WORD,	 false	},	// 4096 models
{ ES_FIELD(colormap),		NET_WORD,	 false	},	// encoded as two shorts for top and bottom color
{ ES_FIELD(scale),			NET_FLOAT, false	},	// 0-255 values
{ ES_FIELD(frame),			NET_FLOAT, false	},	// interpolate value
{ ES_FIELD(animtime),		NET_FLOAT, false	},	// auto-animating time
{ ES_FIELD(framerate),		NET_FLOAT, false	},	// custom framerate
{ ES_FIELD(sequence),		NET_WORD,	 false	},	// 1024 sequences
{ ES_FIELD(gaitsequence),		NET_WORD,	 false	},	// 1024 gaitsequences
{ ES_FIELD(skin),			NET_BYTE,	 false	},	// 255 skins
{ ES_FIELD(body),			NET_BYTE,	 false	},	// 255 bodies
{ ES_FIELD(weaponmodel),		NET_WORD,  false	},	// p_model index, not name 
{ ES_FIELD(contents),		NET_LONG,	 false	},	// full range contents
{ ES_FIELD(solid),			NET_BYTE,	 false	},
{ ES_FIELD(flags),			NET_LONG,  false	},	// misc edict flags
{ ES_FIELD(movetype),		NET_BYTE,	 false	},
{ ES_FIELD(gravity),		NET_SHORT, false	},	// gravity multiplier
{ ES_FIELD(aiment),			NET_SHORT, false	},	// entity index
{ ES_FIELD(owner),			NET_WORD,	 false	},	// entity owner index
{ ES_FIELD(groundent),		NET_SHORT, false	},	// ground entity index, if FL_ONGROUND is set
{ ES_FIELD(solid),			NET_LONG,	 false	},	// encoded mins/maxs
{ ES_FIELD(effects),		NET_LONG,	 false	},	// effect flags
{ ES_FIELD(mins[0]),		NET_FLOAT, false	},
{ ES_FIELD(mins[1]),		NET_FLOAT, false	},
{ ES_FIELD(mins[2]),		NET_FLOAT, false	},
{ ES_FIELD(maxs[0]),		NET_FLOAT, false	},
{ ES_FIELD(maxs[1]),		NET_FLOAT, false	},
{ ES_FIELD(maxs[2]),		NET_FLOAT, false	},	
{ ES_FIELD(renderfx),		NET_LONG,	 false	},	// renderfx flags
{ ES_FIELD(renderamt),		NET_FLOAT, false	},	// alpha amount
{ ES_FIELD(rendercolor[0]),		NET_FLOAT, false	},	// stateflags_t #2 (4 bytes)
{ ES_FIELD(rendercolor[1]),		NET_FLOAT, false	},
{ ES_FIELD(rendercolor[2]),		NET_FLOAT, false	},
{ ES_FIELD(oldorigin[0]),		NET_FLOAT, true	},
{ ES_FIELD(oldorigin[1]),		NET_FLOAT, true	},
{ ES_FIELD(oldorigin[2]),		NET_FLOAT, true	},
{ ES_FIELD(rendermode),		NET_BYTE,  false	},	// render mode (legacy stuff)
{ ES_FIELD(punch_angles[0]),		NET_SCALE, false	},
{ ES_FIELD(punch_angles[1]),		NET_SCALE, false	},
{ ES_FIELD(punch_angles[2]),		NET_SCALE, false	},
{ ES_FIELD(blending[0]),		NET_COLOR, false	},
{ ES_FIELD(blending[1]),		NET_COLOR, false	},	// stateflags_t #1 (4 bytes)
{ ES_FIELD(blending[2]),		NET_COLOR, false	},
{ ES_FIELD(blending[3]),		NET_COLOR, false	},
{ ES_FIELD(blending[4]),		NET_COLOR, false	},
{ ES_FIELD(blending[5]),		NET_COLOR, false	},
{ ES_FIELD(blending[6]),		NET_COLOR, false	},
{ ES_FIELD(blending[7]),		NET_COLOR, false	},
{ ES_FIELD(blending[8]),		NET_COLOR, false	},
{ ES_FIELD(blending[9]),		NET_COLOR, false	},
{ ES_FIELD(controller[0]),		NET_COLOR, false	},	// bone controllers #
{ ES_FIELD(controller[1]),		NET_COLOR, false	},
{ ES_FIELD(controller[2]),		NET_COLOR, false	},
{ ES_FIELD(controller[3]),		NET_COLOR, false	},
{ ES_FIELD(controller[4]),		NET_COLOR, false	},
{ ES_FIELD(controller[5]),		NET_COLOR, false	},
{ ES_FIELD(controller[6]),		NET_COLOR, false	},
{ ES_FIELD(controller[7]),		NET_COLOR, false	},
{ ES_FIELD(controller[8]),		NET_COLOR, false	},
{ ES_FIELD(controller[9]),		NET_COLOR, false	},
{ ES_FIELD(viewangles[0]),		NET_FLOAT, false	},	// for fixed views
{ ES_FIELD(viewangles[1]),		NET_FLOAT, false	},
{ ES_FIELD(viewangles[2]),		NET_FLOAT, false	},
{ ES_FIELD(viewoffset[0]),		NET_SCALE, false	},
{ ES_FIELD(viewoffset[1]),		NET_SCALE, false	},
{ ES_FIELD(viewoffset[2]),		NET_SCALE, false	},
{ ES_FIELD(idealpitch),		NET_SCALE, false	},
{ ES_FIELD(viewmodel),		NET_WORD,  false	},
{ ES_FIELD(maxspeed),		NET_FLOAT, false	},	// client maxspeed
{ ES_FIELD(fov),			NET_FLOAT, false	},	// client horizontal field of view
{ ES_FIELD(weapons),		NET_LONG,  false	},	// client weapon 0-64
{ ES_FIELD(health),			NET_FLOAT, false	},	// client health
// revision 6. reserve for 5 fields without enlarge null_msg_size
{ NULL },							// terminator
};

// probably usercmd_t never reached 32 field integer limit (in theory of course)
static net_field_t cmd_fields[] =
{
{ CM_FIELD(msec),		NET_BYTE,  true	},
{ CM_FIELD(servertime),	NET_LONG,  true	},
{ CM_FIELD(angles[0]),	NET_ANGLE, false	},
{ CM_FIELD(angles[1]),	NET_ANGLE, false	},
{ CM_FIELD(angles[2]),	NET_ANGLE, false	},
{ CM_FIELD(forwardmove),	NET_SHORT, false	},
{ CM_FIELD(sidemove),	NET_SHORT, false	},
{ CM_FIELD(upmove),		NET_SHORT, false	},
{ CM_FIELD(buttons),	NET_SHORT, false	},
{ NULL },
};

/*
=============================================================================

SZ BUFFER (io functions)
  
=============================================================================
*/
/*
=======================
MSG_Init

init new buffer
=======================
*/
void MSG_Init( sizebuf_t *buf, byte *data, size_t length )
{
	Mem_Set( buf, 0, sizeof(*buf));
	buf->data = data;
	buf->maxsize = length;
	Huff_Init();
}

/*
=======================
MSG_GetSpace

get some space for write 
=======================
*/
void *MSG_GetSpace( sizebuf_t *msg, size_t length )
{
	void	*data;
	
	if( msg->cursize + length > msg->maxsize )
	{
		if( length > msg->maxsize )
			Host_Error("MSG_GetSpace: length[%i] > buffer maxsize [%i]\n", length, msg->maxsize );
		MsgDev( D_WARN, "MSG_GetSpace: overflow\n", msg->cursize + length, msg->maxsize );
		MSG_Clear( msg ); 
		msg->overflowed = true;
	}
	data = msg->data + msg->cursize;
	msg->cursize += length;

	return data;
}

/*
=======================
MSG_Print

used for write sv.forward cmds
=======================
*/
void MSG_Print( sizebuf_t *msg, const char *data )
{
	size_t	length = com.strlen(data) + 1;

	if( msg->cursize )
	{
		if(msg->data[msg->cursize - 1]) Mem_Copy((byte *)MSG_GetSpace( msg, length ), data, length );
		else Mem_Copy((byte *)MSG_GetSpace( msg, length - 1) - 1, data, length ); // write over trailing 0
	}
	else Mem_Copy((byte *)MSG_GetSpace( msg, length ), data, length );
}

/*
=======================
MSG_WriteData

used for swap buffers
=======================
*/
void _MSG_WriteData( sizebuf_t *buf, const void *data, size_t length, const char *filename, int fileline )
{
	Mem_Copy( MSG_GetSpace(buf, length), (void *)data, length );	
}

/*
=======================
MSG_Clear

for clearing overflowed buffer
=======================
*/
void MSG_Clear( sizebuf_t *buf )
{
	buf->cursize = 0;
	buf->overflowed = false;
}

void MSG_BeginReading( sizebuf_t *msg )
{
	msg->readcount = 0;
}

/*
=======================
MSG_WriteBits

write # of bytes
=======================
*/
void _MSG_WriteBits( sizebuf_t *msg, long value, const char *name, int net_type, const char *filename, const int fileline )
{
	ftol_t	dat;
	byte	*buf;

	// this isn't an exact overflow check, but close enough
	if( msg->maxsize - msg->cursize < 4 )
	{
		MsgDev( D_ERROR, "MSG_WriteBits: sizebuf overflowed (called at %s:%i)\n", filename, fileline );
		msg->overflowed = true;
		return;
	}
	dat.l = value;

	switch( net_type )
	{
	case NET_SCALE:
		value = dat.f * 4;	
		buf = MSG_GetSpace( msg, 1 );
		buf[0] = value;
		break;
	case NET_COLOR:
		value = bound( 0, dat.f, 255 );
		buf = MSG_GetSpace( msg, 1 );
		buf[0] = value;
		break;
	case NET_CHAR:
	case NET_BYTE:
		buf = MSG_GetSpace( msg, 1 );
		buf[0] = value;
		break;
	case NET_SHORT:
	case NET_WORD:
		buf = MSG_GetSpace( msg, 2 );
		buf[0] = value & 0xff;
		buf[1] = value>>8;
		break;
	case NET_LONG:
	case NET_FLOAT:
		buf = MSG_GetSpace( msg, 4 );
		buf[0] = (value>>0 ) & 0xff;
		buf[1] = (value>>8 ) & 0xff;
		buf[2] = (value>>16) & 0xff;
		buf[3] = (value>>24);
		break;
	case NET_ANGLE8:
		if( dat.f > 360 ) dat.f -= 360; 
		else if( dat.f < 0 ) dat.f += 360;
		value = ANGLE2CHAR( dat.f );
		buf = MSG_GetSpace( msg, 1 );
		buf[0] = value;
		break;
	case NET_ANGLE:
		if( dat.f > 360 ) dat.f -= 360; 
		else if( dat.f < 0 ) dat.f += 360;
		value = ANGLE2SHORT( dat.f );
		buf = MSG_GetSpace( msg, 2 );
		buf[0] = value & 0xff;
		buf[1] = value>>8;
		break;
	case NET_COORD:
		value = dat.f * 8;	
		buf = MSG_GetSpace( msg, 2 );
		buf[0] = value & 0xff;
		buf[1] = value>>8;
		break;
	default:
		Host_Error( "MSG_WriteBits: bad net.type (called at %s:%i)\n", filename, fileline );			
		break;
	}

	if((NWDesc[net_type].min_range + NWDesc[net_type].max_range) != 0 )
	{
		// check range
		if( value < NWDesc[net_type].min_range || value > NWDesc[net_type].max_range )
		{
			MsgDev( D_INFO, "MSG_Write%s: ", NWDesc[net_type].name );
			if( name ) MsgDev( D_INFO, "'%s' ", name );
			MsgDev( D_INFO, "range error %i should be in range (%i", value, NWDesc[net_type].min_range );
			MsgDev( D_INFO, " %i)(called at %s:%i)\n", NWDesc[net_type].max_range, filename, fileline );
          	}
          }
}

/*
=======================
MSG_ReadBits

read # of bytes
=======================
*/
long _MSG_ReadBits( sizebuf_t *msg, int net_type, const char *filename, const int fileline )
{
	ftol_t	dat;
	long	value = 0;

	switch( net_type )
	{
	case NET_SCALE:
		value = (signed char)(msg->data[msg->readcount]);
		dat.f = value * 0.25f;
		msg->readcount += 1;
		break;
	case NET_COLOR:
		value = (byte)(msg->data[msg->readcount]);
		dat.f = value;
		msg->readcount += 1;
		break;
	case NET_CHAR:
		dat.l = (signed char)msg->data[msg->readcount];
		msg->readcount += 1;
		break;
	case NET_BYTE:
		dat.l = (byte)msg->data[msg->readcount];
		msg->readcount += 1;
		break;
	case NET_WORD:
	case NET_SHORT:
		dat.l = (short)BuffLittleShort( msg->data + msg->readcount );
		msg->readcount += 2;
		break;
	case NET_LONG:
	case NET_FLOAT:
		dat.l = (long)BuffLittleLong( msg->data + msg->readcount );
		msg->readcount += 4;
		break;
	case NET_ANGLE8:
		value = (unsigned char)msg->data[msg->readcount];
		dat.f = CHAR2ANGLE( value );
		if( dat.f < -180 ) dat.f += 360; 
		else if( dat.f > 180 ) dat.f -= 360;
		msg->readcount += 1;
		break;
	case NET_ANGLE:
		value = (unsigned short)BuffLittleShort( msg->data + msg->readcount );
		dat.f = SHORT2ANGLE( value );
		if( dat.f < -180 ) dat.f += 360; 
		else if( dat.f > 180 ) dat.f -= 360;
		msg->readcount += 2;
		break;		
	case NET_COORD:
		value = (short)BuffLittleShort( msg->data + msg->readcount );
		dat.f = value * 0.125f;
		msg->readcount += 2;
		break;		
	default:
		Host_Error( "MSG_ReadBits: bad net.type (called at %s:%i)\n", filename, fileline );			
		break;
	}

	value = dat.l;

	// end of message or error reading
	if( msg->readcount > msg->cursize )
	{
		if(( msg->readcount - msg->cursize ) > 1 )
		{
			MsgDev( D_ERROR, "MSG_Read%s: ", NWDesc[net_type].name );
			MsgDev( D_ERROR, "msg total size %i, reading %i\n", msg->cursize, msg->readcount );
			msg->error = true;
		}
		return -1;
	}
	return value;
}

/*
==============================================================================

			MESSAGE IO FUNCTIONS
	       Handles byte ordering and avoids alignment errors
==============================================================================
*/
/*
=======================
   writing functions
=======================
*/
void _MSG_WriteAngle8( sizebuf_t *sb, float f, const char *filename, int fileline )
{
	union { float f; int l; } dat;
	dat.f = f;
	_MSG_WriteBits( sb, dat.l, NWDesc[NET_ANGLE8].name, NET_ANGLE8, filename, fileline );
}

void _MSG_WriteAngle16( sizebuf_t *sb, float f, const char *filename, int fileline )
{
	union { float f; int l; } dat;
	dat.f = f;
	_MSG_WriteBits( sb, dat.l, NWDesc[NET_ANGLE].name, NET_ANGLE, filename, fileline );
}

void _MSG_WriteCoord16( sizebuf_t *sb, float f, const char *filename, int fileline )
{
	union { float f; int l; } dat;
	dat.f = f;
	_MSG_WriteBits( sb, dat.l, NWDesc[NET_COORD].name, NET_COORD, filename, fileline );
}

void _MSG_WriteFloat( sizebuf_t *sb, float f, const char *filename, int fileline )
{
	union { float f; int l; } dat;
	dat.f = f;
	_MSG_WriteBits( sb, dat.l, NWDesc[NET_FLOAT].name, NET_FLOAT, filename, fileline );
}

void _MSG_WriteString( sizebuf_t *sb, const char *s, const char *filename, int fileline )
{
	if( !s ) _MSG_WriteData( sb, "", 1, filename, fileline );
	else
	{
		int	l, i;
		char	string[MAX_SYSPATH];
                    
		l = com.strlen( s ) + 1;		
		if( l >= MAX_SYSPATH )
		{
			MsgDev( D_ERROR, "MSG_WriteString: exceeds %i symbols (called at %s:%i\n", MAX_SYSPATH, filename, fileline );
			_MSG_WriteData( sb, "", 1, filename, fileline );
			return;
		}
		com.strncpy( string, s, sizeof( string ));

		// get rid of 0xff chars, because old clients don't like them
		for( i = 0; i < l; i++ )
		{
			if(((byte *)string)[i] > 127 )
				string[i] = '.';
		}
		_MSG_WriteData( sb, string, l, filename, fileline );
	}
}

void _MSG_WritePos( sizebuf_t *sb, vec3_t pos, const char *filename, int fileline )
{
	_MSG_WriteFloat( sb, pos[0], filename, fileline );
	_MSG_WriteFloat( sb, pos[1], filename, fileline );
	_MSG_WriteFloat( sb, pos[2], filename, fileline );
}

/*
=======================
   reading functions
=======================
*/
float MSG_ReadFloat( sizebuf_t *msg )
{
	union { float f; int l; } dat;
	dat.l = MSG_ReadBits( msg, NET_FLOAT );
	return dat.f;	
}

float MSG_ReadAngle8( sizebuf_t *msg )
{
	union { float f; int l; } dat;
	dat.l = MSG_ReadBits( msg, NET_ANGLE8 );
	return dat.f;	
}

float MSG_ReadAngle16( sizebuf_t *msg )
{
	union { float f; int l; } dat;
	dat.l = MSG_ReadBits( msg, NET_ANGLE );
	return dat.f;	
}

float MSG_ReadCoord16( sizebuf_t *msg )
{
	union { float f; int l; } dat;
	dat.l = MSG_ReadBits( msg, NET_COORD );
	return dat.f;
}

char *MSG_ReadString( sizebuf_t *msg )
{
	static char	string[MAX_SYSPATH];
	int		l = 0, c;
	
	do
	{
		// use MSG_ReadByte so -1 is out of bounds
		c = MSG_ReadByte( msg );
		if( c == -1 || c == '\0' )
			break;

		// translate all fmt spec to avoid crash bugs
		if( c == '%' ) c = '.';
		// don't allow higher ascii values
		if( c > 127 ) c = '.';

		string[l] = c;
		l++;
	} while( l < sizeof(string) - 1 );
	string[l] = 0; // terminator
	
	return string;
}

char *MSG_ReadStringLine( sizebuf_t *msg )
{
	static char	string[MAX_SYSPATH];
	int		l = 0, c;
	
	do
	{
		// use MSG_ReadByte so -1 is out of bounds
		c = MSG_ReadByte( msg );
		if( c == -1 || c == '\0' || c == '\n' )
			break;

		// translate all fmt spec to avoid crash bugs
		if( c == '%' ) c = '.';

		string[l] = c;
		l++;
	} while( l < sizeof(string) - 1 );
	string[l] = 0; // terminator
	
	return string;
}

void MSG_ReadData( sizebuf_t *msg, void *data, size_t length )
{
	int	i;
	for( i = 0; i < length; i++ )
		((byte *)data)[i] = MSG_ReadByte( msg );
}

void MSG_ReadPos( sizebuf_t *msg_read, vec3_t pos )
{
	pos[0] = MSG_ReadFloat( msg_read );
	pos[1] = MSG_ReadFloat( msg_read );
	pos[2] = MSG_ReadFloat( msg_read );
}

/*
=============================================================================

delta functions
  
=============================================================================
*/
/*
=====================
MSG_WriteDeltaUsercmd
=====================
*/
void _MSG_WriteDeltaUsercmd( sizebuf_t *msg, usercmd_t *from, usercmd_t *to, const char *filename, const int fileline )
{
	int		num_fields;
	net_field_t	*field;
	int		*fromF, *toF;
	int		i, flags = 0;
	
	num_fields = (sizeof(cmd_fields) / sizeof(cmd_fields[0])) - 1;
	if( num_fields > 31 ) return; // this should never happen

	// compare fields
	for( i = 0, field = cmd_fields; i < num_fields; i++, field++ )
	{
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );
		if(*fromF != *toF || field->force) flags |= 1<<i;
	}
	if( flags == 0 )
	{
		// nothing at all changed
		MSG_WriteLong( msg, -99 ); // no delta info
		return;
	}		

	MSG_WriteLong( msg, flags );	// send flags who indicates changes
	for( i = 0, field = cmd_fields; i < num_fields; i++, field++ )
	{
		toF = (int *)((byte *)to + field->offset );
		if( flags & 1<<i ) MSG_WriteBits( msg, *toF, field->name, field->bits );
	}
}

/*
=====================
MSG_ReadDeltaUsercmd
=====================
*/
void MSG_ReadDeltaUsercmd( sizebuf_t *msg, usercmd_t *from, usercmd_t *to )
{
	net_field_t	*field;
	int		i, flags;
	int		*fromF, *toF;

	*to = *from;

	if(*(int *)&msg->data[msg->readcount] == -99 )
	{
		MSG_ReadLong( msg );
		return;
	}
	for( i = 0, field = cmd_fields; field->name; i++, field++ )
	{
		// get flags of next packet if LONG out of range
		if((i & 31) == 0) flags = MSG_ReadLong( msg );
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );
		
		if(flags & (1<<i)) *toF = MSG_ReadBits( msg, field->bits );
		else *toF = *fromF;	// no change
	}
}

/*
=============================================================================

entity_state_t communication
  
=============================================================================
*/
#if 1
void _MSG_WriteDeltaEntity( entity_state_t *from, entity_state_t *to, sizebuf_t *msg, bool force, bool newentity, const char *filename, int fileline ) 
{
	net_field_t	*field, *field2;
	int		i, j, k, flags = 0;
	int		*fromF, *toF;
	int		num_fields;
	size_t		null_msg_size;
	size_t		buff_size;

	if( to == NULL )
	{
		if( from == NULL ) return;

		// a NULL 'to' is a delta remove message
		MSG_WriteBits( msg, from->number, NWDesc[NET_WORD].name, NET_WORD );
		MSG_WriteBits( msg, 0xFFFF, NWDesc[NET_LONG].name, NET_LONG );
		return;
	}

	num_fields = sizeof(ent_fields) / sizeof(net_field_t);
	null_msg_size = (( num_fields / 32 ) + (( num_fields % 32 ) ? 1 : 0 )) * 4 + sizeof(short);
	buff_size = msg->cursize;

	if( to->number < 0 || to->number >= GI->max_edicts )
		Host_Error( "MSG_WriteDeltaEntity: Bad entity number: %i (called at %s:%i)\n", to->number, filename, fileline );

	MSG_WriteBits( msg, to->number, NWDesc[NET_WORD].name, NET_WORD );
	for( i = j = 0, field = field2 = ent_fields; field->name; i++, j++, field++ )
	{
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );		
		if(*fromF != *toF || (newentity && field->force)) flags |= 1<<j;
		if( j > 31 || !ent_fields[i+1].name) // dump packet
		{
			MSG_WriteLong( msg, flags );	// send flags who indicates changes
			for( k = 0; field2->name; k++, field2++ )
			{
				if( k > 31 ) break; // return to main cycle
				toF = (int *)((byte *)to + field2->offset );
				if( flags & (1<<k)) MSG_WriteBits( msg, *toF, field2->name, field2->bits );
			}
			j = flags = 0;
		}
	}

	// NOTE: null_msg_size is number of (ent_fields / 32) + (1), 
	// who indicates flags count multiplied by sizeof(long)
	// plus sizeof(short) (head number). if message equal null_message_size
	// we will be ignore it 
	if( !force && (( msg->cursize - buff_size ) == null_msg_size ))
		msg->cursize = buff_size; // kill message
}

/*
==================
MSG_ReadDeltaEntity

The entity number has already been read from the message, which
is how the from state is identified.
                             
If the delta removes the entity, entity_state_t->number will be set to MAX_EDICTS - 1

Can go from either a baseline or a previous packet_entity
==================
*/
void MSG_ReadDeltaEntity( sizebuf_t *msg, entity_state_t *from, entity_state_t *to, int number )
{
	net_field_t	*field;
	int		i, flags;
	int		*fromF, *toF;

	if( number < 0 || number >= GI->max_edicts )
		Host_Error( "MSG_ReadDeltaEntity: bad delta entity number: %i\n", number );

	*to = *from;
	to->number = number;

	if(*(int *)&msg->data[msg->readcount] == 0xFFFF )
	{
		// check for a remove
		MSG_ReadLong( msg );
		Mem_Set( to, 0, sizeof( *to ));	
		to->number = MAX_EDICTS - 1;	// entity was removed
		return;
	}
	for( i = 0, field = ent_fields; field->name; i++, field++ )
	{
		// get flags of next packet if LONG out of range
		if((i & 31) == 0) flags = MSG_ReadLong( msg );
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );
		
		if(flags & (1<<i)) *toF = MSG_ReadBits( msg, field->bits );
		else *toF = *fromF;	// no change
	}
}

#else

enum
{
	U_ED_TYPE		= BIT( 0 ),
	U_CLASSNAME	= BIT( 1 ),
	U_ED_FLAGS	= BIT( 2 ),	// 0 compressed
	U_ORIGIN		= BIT( 3 ),
	U_ANGLES		= BIT( 4 ),
	U_SOLID		= BIT( 5 ),
	U_MOVETYPE	= BIT( 6 ),
	U_AIMENT		= BIT( 7 ),
	U_OWNER		= BIT( 8 ),
	U_GROUNDENT	= BIT( 9 ),
	U_MINMAXS		= BIT( 10 ),	// mins\maxs changed
	U_VELOCITY	= BIT( 11 ),
	U_OLDORIGIN	= BIT( 12 ),
	U_MODELINDEX	= BIT( 13 ),
	U_COLORMAP	= BIT( 14 ),
	U_SCALE		= BIT( 15 ),
	U_FRAME		= BIT( 16 ),
	U_SKIN		= BIT( 17 ),
	U_BODY		= BIT( 18 ),
	U_ANIMTIME	= BIT( 19 ),
	U_FRAMERATE	= BIT( 20 ),
	U_SEQUENCE	= BIT( 21 ),
	U_FLAGS		= BIT( 22 ),
	U_EFFECTS		= BIT( 23 ),
	U_RENDERFX	= BIT( 24 ),
	U_RENDERAMT	= BIT( 25 ),
	U_RENDERCOLOR	= BIT( 26 ),
	U_RENDERMODE	= BIT( 27 ),
	U_WEAPONMODEL	= BIT( 28 ),
};

enum
{
	// bits 0 - 15 are reserved for bonecontrollers
	U_PUNCHANGLES	= BIT( 16 ),
	U_VIEWANGLES	= BIT( 17 ),
	U_VIEWOFS		= BIT( 18 ),
	U_GAITSEQUENCE	= BIT( 19 ),
	U_VIEWMODEL	= BIT( 20 ),
	U_IDEALPITCH	= BIT( 21 ),
	U_HEALTH		= BIT( 22 ),
	U_WEAPONS		= BIT( 23 ),
	U_FOV		= BIT( 24 ),
};

/*
==================
MSG_WriteDeltaEntity

Writes part of a packetentities message, including the entity number.
Can delta from either a baseline or a previous packet_entity
If to is NULL, a remove entity update will be sent
If force is not set, then nothing at all will be generated if the entity is
identical, under the assumption that the in-order delta code will catch it.
==================
*/
void _MSG_WriteDeltaEntity( entity_state_t *from, entity_state_t *to, sizebuf_t *msg, bool force, bool newentity, const char *filename, int fileline ) 
{
	int	i, bits, bits2;

	if( to == NULL )
	{
		if( from == NULL ) return;

		// a NULL 'to' is a delta remove message
		MSG_WriteBits( msg, from->number, NWDesc[NET_WORD].name, NET_WORD );
		MSG_WriteBits( msg, 0xFFFF, NWDesc[NET_LONG].name, NET_LONG );
		return;
	}

	if( to->number < 0 || to->number >= GI->max_edicts )
		Host_Error( "MSG_WriteDeltaEntity: Bad entity number: %i (called at %s:%i)\n", to->number, filename, fileline );

	bits = bits2 = 0;

	if( to->ed_type != from->ed_type )
		bits |= U_ED_TYPE;

	if( to->classname != from->classname )
		bits |= U_CLASSNAME;

	if( to->ed_flags )
		bits |= U_ED_FLAGS;

	if( !VectorCompare( to->origin, from->origin ))
		bits |= U_ORIGIN;

	if( !VectorCompare( to->origin, from->origin ))
		bits |= U_ANGLES;

	if( to->solid != from->solid )
		bits |= U_SOLID;

	if( to->movetype != from->movetype )
		bits |= U_MOVETYPE;

	if( to->aiment != from->aiment )
		bits |= U_AIMENT;

	if( to->owner != from->owner )
		bits |= U_OWNER;

	if( to->groundent != from->groundent )
		bits |= U_GROUNDENT;

	if( !VectorCompare( to->mins, from->mins ) || !VectorCompare( to->maxs, from->maxs ))
		bits |= U_MINMAXS;

	if( !VectorCompare( to->velocity, from->velocity ))
		bits |= U_VELOCITY;

	if( !VectorCompare( to->oldorigin, from->oldorigin ))
		bits |= U_OLDORIGIN;

	if( to->modelindex != from->modelindex )
		bits |= U_MODELINDEX;

	if( to->colormap != from->colormap )
		bits |= U_COLORMAP;

	if( to->scale != from->scale )
		bits |= U_SCALE;

	if( to->frame != from->frame )
		bits |= U_FRAME;

	if( to->skin != from->skin )
		bits |= U_SKIN;

	if( to->body != from->body )
		bits |= U_BODY;

	if( to->animtime != from->animtime )
		bits |= U_ANIMTIME;

	if( to->framerate != from->framerate )
		bits |= U_FRAMERATE;

	if( to->sequence != from->sequence )
		bits |= U_SEQUENCE;

	if( to->flags != from->flags )
		bits |= U_FLAGS;

	if( to->effects != from->effects )
		bits |= U_EFFECTS;

	if( to->renderfx != from->renderfx )
		bits |= U_RENDERFX;

	if( to->renderamt != from->renderamt )
		bits |= U_RENDERAMT;

	if( !VectorCompare( to->rendercolor, from->rendercolor ))
		bits |= U_RENDERCOLOR;

	if( to->rendermode != from->rendermode )
		bits |= U_RENDERMODE;

	if( to->weaponmodel != from->weaponmodel )
		bits |= U_WEAPONMODEL;

	for( i = 0; i < 16; i++ )
	{
		if( to->controller[i] != from->controller[i] )
			bits2 |= (1<<i);
	}

	// bits are near full, store flags into bits2
	if( !VectorCompare( to->punch_angles, from->punch_angles ))
		bits2 |= U_PUNCHANGLES;

	if( !VectorCompare( to->viewangles, from->viewangles ))
		bits2 |= U_VIEWANGLES;

	if( !VectorCompare( to->viewoffset, from->viewoffset ))
		bits2 |= U_VIEWOFS;

	if( to->gaitsequence != from->gaitsequence )
		bits2 |= U_GAITSEQUENCE;

	if( to->viewmodel != from->viewmodel )
		bits2 |= U_VIEWMODEL;

	if( to->idealpitch != from->idealpitch )
		bits2 |= U_IDEALPITCH;

	if( to->health != from->health )
		bits2 |= U_HEALTH;

	if( to->weapons != from->weapons )
		bits2 |= U_WEAPONS;

	if( to->fov != from->fov )
		bits2 |= U_FOV;

	// Write the message
	if( !bits && !bits2 && !force )
		return;	// nothing to send!

	MSG_WriteWord( msg, to->number );
	MSG_WriteLong( msg, bits );

	// write additional bits for client state flags
	MSG_WriteLong( msg, bits2 );

	if( bits & U_ED_TYPE )
		MSG_WriteByte( msg, to->ed_type );

	if( bits & U_CLASSNAME )
		MSG_WriteByte( msg, to->classname );

	if( bits & U_ED_FLAGS )
		MSG_WriteByte( msg, to->ed_flags );

	if( bits & U_ORIGIN )
		MSG_WritePos( msg, to->origin );

	if( bits & U_ANGLES )
		MSG_WritePos( msg, to->angles );

	if( bits & U_SOLID )
		MSG_WriteByte( msg, to->solid );

	if( bits & U_MOVETYPE )
		MSG_WriteByte( msg, to->movetype );

	if( bits & U_AIMENT )
		MSG_WriteShort( msg, to->aiment );

	if( bits & U_OWNER )
		MSG_WriteShort( msg, to->owner );

	if( bits & U_GROUNDENT )
		MSG_WriteShort( msg, to->groundent );

	if( bits & U_MINMAXS )
	{
		MSG_WritePos( msg, to->mins );
		MSG_WritePos( msg, to->maxs );
	}

	if( bits & U_VELOCITY )
		MSG_WritePos( msg, to->velocity );

	if( bits & U_OLDORIGIN )
		MSG_WritePos( msg, to->oldorigin );

	if( bits & U_MODELINDEX )
		MSG_WriteWord( msg, to->modelindex );

	if( bits & U_COLORMAP )
		MSG_WriteWord( msg, to->colormap );

	if( bits & U_SCALE )
		MSG_WriteFloat( msg, to->scale );

	if( bits & U_FRAME )
		MSG_WriteFloat( msg, to->frame );

	if( bits & U_SKIN )
		MSG_WriteByte( msg, to->skin );

	if( bits & U_BODY )
		MSG_WriteByte( msg, to->body );

	if( bits & U_ANIMTIME )
		MSG_WriteFloat( msg, to->animtime );

	if( bits & U_FRAMERATE )
		MSG_WriteFloat( msg, to->framerate );

	if( bits & U_SEQUENCE )
		MSG_WriteWord( msg, to->sequence );

	if( bits & U_FLAGS )
		MSG_WriteLong( msg, to->flags );

	if( bits & U_EFFECTS )
		MSG_WriteLong( msg, to->effects );

	if( bits & U_RENDERFX )
		MSG_WriteByte( msg, to->renderfx );

	if( bits & U_RENDERAMT )
		MSG_WriteFloat( msg, to->renderamt );

	if( bits & U_RENDERCOLOR )
		MSG_WritePos( msg, to->rendercolor );

	if( bits & U_RENDERMODE )
		MSG_WriteByte( msg, to->rendermode );

	if( bits & U_WEAPONMODEL )
		MSG_WriteWord( msg, to->weaponmodel );

	// bits are near full, store flags into bits2
	for( i = 0; i < 16; i++ )
	{
		if( bits2 & (1<<i) )
			MSG_WriteFloat( msg, to->controller[i] );
	}
	
	if( bits2 & U_PUNCHANGLES )
		MSG_WritePos( msg, to->punch_angles );

	if( bits2 & U_VIEWANGLES )
		MSG_WritePos( msg, to->viewangles );

	if( bits2 & U_VIEWOFS )
		MSG_WritePos( msg, to->viewoffset );

	if( bits2 & U_GAITSEQUENCE )
		MSG_WriteWord( msg, to->gaitsequence );

	if( bits2 & U_VIEWMODEL )
		MSG_WriteWord( msg, to->viewmodel );

	if( bits2 & U_IDEALPITCH )
		MSG_WriteFloat( msg, to->idealpitch );

	if( bits2 & U_HEALTH )
		MSG_WriteFloat( msg, to->health );

	if( bits2 & U_WEAPONS )
		MSG_WriteLong( msg, to->weapons );

	if( bits2 & U_FOV )
		MSG_WriteFloat( msg, to->fov );
}

/*
==================
MSG_ReadDeltaEntity

The entity number has already been read from the message, which
is how the from state is identified.
                             
If the delta removes the entity, entity_state_t->number will be set to MAX_EDICTS - 1

Can go from either a baseline or a previous packet_entity
==================
*/
void MSG_ReadDeltaEntity( sizebuf_t *msg, entity_state_t *from, entity_state_t *to, int number )
{
	int	i, bits, bits2;

	if( number < 0 || number >= GI->max_edicts )
		Host_Error( "MSG_ReadDeltaEntity: bad delta entity number: %i\n", number );

	*to = *from;
	to->number = number;
	bits = bits2 = 0;

	if(*(int *)&msg->data[msg->readcount] == 0xFFFF )
	{
		// check for a remove
		MSG_ReadLong( msg );
		Mem_Set( to, 0, sizeof( *to ));	
		to->number = MAX_EDICTS - 1;	// entity was removed
		return;
	}

	bits = MSG_ReadLong( msg );

	// write additional bits for client state flags
	bits2 = MSG_ReadLong( msg );

	if( bits & U_ED_TYPE )
		to->ed_type = MSG_ReadByte( msg );

	if( bits & U_CLASSNAME )
		to->classname = MSG_ReadByte( msg );

	if( bits & U_ED_FLAGS )
		to->ed_flags = MSG_ReadByte( msg );

	if( bits & U_ORIGIN )
		MSG_ReadPos( msg, to->origin );

	if( bits & U_ANGLES )
		MSG_ReadPos( msg, to->angles );

	if( bits & U_SOLID )
		to->solid = MSG_ReadByte( msg );

	if( bits & U_MOVETYPE )
		to->movetype = MSG_ReadByte( msg );

	if( bits & U_AIMENT )
		to->aiment = MSG_ReadShort( msg );

	if( bits & U_OWNER )
		to->owner = MSG_ReadShort( msg );

	if( bits & U_GROUNDENT )
		to->groundent = MSG_ReadShort( msg );

	if( bits & U_MINMAXS )
	{
		MSG_ReadPos( msg, to->mins );
		MSG_ReadPos( msg, to->maxs );
	}

	if( bits & U_VELOCITY )
		MSG_ReadPos( msg, to->velocity );

	if( bits & U_OLDORIGIN )
		MSG_ReadPos( msg, to->oldorigin );

	if( bits & U_MODELINDEX )
		to->modelindex = MSG_ReadWord( msg );

	if( bits & U_COLORMAP )
		to->colormap = MSG_ReadWord( msg );

	if( bits & U_SCALE )
		to->scale = MSG_ReadFloat( msg );

	if( bits & U_FRAME )
		to->frame = MSG_ReadFloat( msg );

	if( bits & U_SKIN )
		to->skin = MSG_ReadByte( msg );

	if( bits & U_BODY )
		to->body = MSG_ReadByte( msg );

	if( bits & U_ANIMTIME )
		to->animtime = MSG_ReadFloat( msg );

	if( bits & U_FRAMERATE )
		to->framerate = MSG_ReadFloat( msg );

	if( bits & U_SEQUENCE )
		to->sequence = MSG_ReadWord( msg );

	if( bits & U_FLAGS )
		to->flags = MSG_ReadLong( msg );

	if( bits & U_EFFECTS )
		to->effects = MSG_ReadLong( msg );

	if( bits & U_RENDERFX )
		to->renderfx = MSG_ReadByte( msg );

	if( bits & U_RENDERAMT )
		to->renderamt = MSG_ReadFloat( msg );

	if( bits & U_RENDERCOLOR )
		MSG_ReadPos( msg, to->rendercolor );

	if( bits & U_RENDERMODE )
		to->rendermode = MSG_ReadByte( msg );

	if( bits & U_WEAPONMODEL )
		to->weaponmodel = MSG_ReadWord( msg );

	// bits are near full, store flags into bits2
	for( i = 0; i < 16; i++ )
	{
		if( bits2 & (1<<i) )
			to->controller[i] = MSG_ReadFloat( msg );
	}

	if( bits2 & U_PUNCHANGLES )
		MSG_ReadPos( msg, to->punch_angles );

	if( bits2 & U_VIEWANGLES )
		MSG_ReadPos( msg, to->viewangles );

	if( bits2 & U_VIEWOFS )
		MSG_ReadPos( msg, to->viewoffset );

	if( bits2 & U_GAITSEQUENCE )
		to->gaitsequence = MSG_ReadWord( msg );

	if( bits2 & U_VIEWMODEL )
		to->viewmodel = MSG_ReadWord( msg );

	if( bits2 & U_IDEALPITCH )
		to->idealpitch = MSG_ReadFloat( msg );

	if( bits2 & U_HEALTH )
		to->health = MSG_ReadFloat( msg );

	if( bits2 & U_WEAPONS )
		to->weapons = MSG_ReadLong( msg );

	if( bits2 & U_FOV )
		to->fov = MSG_ReadFloat( msg );
}

#endif

/*
============================================================================

player state communication

============================================================================
*/
/*
===================
MSG_ParseDeltaPlayer
===================
*/
entity_state_t MSG_ParseDeltaPlayer( entity_state_t *from, entity_state_t *to )
{
	net_field_t	*field;
	int		*fromF, *toF, *outF;
	entity_state_t	dummy, result, *out;
	uint		i;

	// alloc space to copy state
	Mem_Set( &result, 0, sizeof( result ));
	out = &result;

	// clear to old value before delta parsing
	if( !from )
	{
		from = &dummy;
		Mem_Set( &dummy, 0, sizeof( dummy ));
	}
	*out = *from;
	
	for( i = 0, field = ent_fields; field->name; i++, field++ )
	{
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );
		outF = (int *)((byte *)out + field->offset );
		if( *fromF != *toF ) *outF = *toF;
	}

	return result;
}

/*
============================================================================

player state communication

============================================================================
*/
/*
=============
MSG_WriteDeltaPlayerstate

=============
*/
void MSG_WriteDeltaPlayerstate( entity_state_t *from, entity_state_t *to, sizebuf_t *msg )
{
	entity_state_t	dummy;
	entity_state_t	*ops, *ps = to;
	net_field_t	*field, *field2;
	int		*fromF, *toF;
	int		i, j, k;
	uint		flags = 0;
	
	if( !from )
	{
		Mem_Set (&dummy, 0, sizeof(dummy));
		ops = &dummy;
	}
	else ops = from;
	from = to;
	
	MSG_WriteByte( msg, svc_playerinfo );
 
	for( i = j = 0, field = field2 = ent_fields; field->name; i++, j++, field++ )
	{
		fromF = (int *)((byte *)ops + field->offset );
		toF = (int *)((byte *)ps + field->offset );		
		if(*fromF != *toF || field->force) flags |= 1<<j;
		if( j > 31 || !ent_fields[i+1].name) // dump packet
		{
			MSG_WriteLong( msg, flags );	// send flags who indicates changes
			for( k = 0; field2->name; k++, field2++ )
			{
				if( k > 31 ) break; // return to main cycle
				toF = (int *)((byte *)ps + field2->offset );
				if( flags & 1<<k ) MSG_WriteBits( msg, *toF, field2->name, field2->bits );
			}
			j = flags = 0;
		}
	}
}


/*
===================
MSG_ReadDeltaPlayerstate
===================
*/
void MSG_ReadDeltaPlayerstate( sizebuf_t *msg, entity_state_t *from, entity_state_t *to )
{
	net_field_t	*field;
	int		*fromF, *toF;
	entity_state_t	dummy;
	uint		i, flags;

	// clear to old value before delta parsing
	if( !from )
	{
		from = &dummy;
		Mem_Set( &dummy, 0, sizeof( dummy ));
	}
	*to = *from;
	
	for( i = 0, field = ent_fields; field->name; i++, field++ )
	{
		// get flags of next packet if LONG out of range
		if((i & 31) == 0) flags = MSG_ReadLong( msg );
		fromF = (int *)((byte *)from + field->offset );
		toF = (int *)((byte *)to + field->offset );
		
		if(flags & (1<<i)) *toF = MSG_ReadBits( msg, field->bits );
		else *toF = *fromF;	// no change
	}
}