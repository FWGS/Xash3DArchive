//=======================================================================
//			Copyright XashXT Group 2010 ©
//		     gl_local.h - renderer local declarations
//=======================================================================

#ifndef GL_LOCAL_H
#define GL_LOCAL_H

#include "gl_export.h"
#include "com_model.h"
#include "cl_entity.h"
#include "ref_params.h"
#include "protocol.h"
#include "dlight.h"

extern byte	*r_temppool;

#define BLOCK_WIDTH		128	// lightmap block width
#define BLOCK_HEIGHT	128	// lightmap block height

#define MAX_TEXTURES	2048
#define MAX_LIGHTMAPS	64
#define SUBDIVIDE_SIZE	64

// renderer flags
#define RDF_PORTALINVIEW	BIT( 0 )	// draw portal pass
#define RDF_SKYPORTALINVIEW	BIT( 1 )	// draw skyportal instead of regular sky

// refparams
#define RP_NONE		0
#define RP_MIRRORVIEW	BIT( 0 )	// lock pvs at vieworg
#define RP_PORTALVIEW	BIT( 1 )
#define RP_ENVVIEW		BIT( 2 )	// used for cubemapshot
#define RP_OLDVIEWLEAF	BIT( 3 )
#define RP_CLIPPLANE	BIT( 4 )
#define RP_FLIPFRONTFACE	BIT( 5 )	// e.g. for mirrors drawing
#define RP_SHADOWMAPVIEW	BIT( 6 )
#define RP_SKYPORTALVIEW	BIT( 7 )
#define RP_NOSKY		BIT( 8 )

#define RP_NONVIEWERREF	(RP_PORTALVIEW|RP_MIRRORVIEW|RP_ENVVIEW|RP_SKYPORTALVIEW|RP_SHADOWMAPVIEW)
#define RP_LOCALCLIENT( e )	(CL_GetLocalPlayer() && ((e)->index == CL_GetLocalPlayer()->index && e->player ))

typedef enum
{
	TEX_INVALID = 0,	// free slot
	TEX_SYSTEM,	// generated by engine
	TEX_NOMIP,	// hud pics, menu etc
	TEX_BRUSH,	// a map texture
	TEX_SPRITE,	// sprite frames
	TEX_STUDIO,	// studio skins
	TEX_LIGHTMAP,	// lightmap textures
	TEX_DECAL,	// decals
	TEX_SKYBOX,	// skybox or sky layers
	TEX_CUBEMAP	// cubemap textures
} texType_t;

enum
{
	GLSTATE_NONE = 0,
	GLSTATE_SRCBLEND_ZERO		= 1,
	GLSTATE_SRCBLEND_ONE		= 2,
	GLSTATE_SRCBLEND_DST_COLOR		= 1|2,
	GLSTATE_SRCBLEND_ONE_MINUS_DST_COLOR	= 4,
	GLSTATE_SRCBLEND_SRC_ALPHA		= 1|4,
	GLSTATE_SRCBLEND_ONE_MINUS_SRC_ALPHA	= 2|4,
	GLSTATE_SRCBLEND_DST_ALPHA		= 1|2|4,
	GLSTATE_SRCBLEND_ONE_MINUS_DST_ALPHA	= 8,
	GLSTATE_DSTBLEND_ZERO		= 16,
	GLSTATE_DSTBLEND_ONE		= 32,
	GLSTATE_DSTBLEND_SRC_COLOR		= 16|32,
	GLSTATE_DSTBLEND_ONE_MINUS_SRC_COLOR	= 64,
	GLSTATE_DSTBLEND_SRC_ALPHA		= 16|64,
	GLSTATE_DSTBLEND_ONE_MINUS_SRC_ALPHA	= 32|64,
	GLSTATE_DSTBLEND_DST_ALPHA		= 16|32|64,
	GLSTATE_DSTBLEND_ONE_MINUS_DST_ALPHA	= 128,
	GLSTATE_BLEND_MTEX			= 0x100,
	GLSTATE_AFUNC_GT0			= 0x200,
	GLSTATE_AFUNC_LT128			= 0x400,
	GLSTATE_AFUNC_GE128			= 0x800,
	GLSTATE_DEPTHWRITE			= 0x1000,
	GLSTATE_DEPTHFUNC_EQ		= 0x2000,
	GLSTATE_OFFSET_FILL			= 0x4000,
	GLSTATE_NO_DEPTH_TEST		= 0x8000,
	GLSTATE_MARK_END			= 0x10000 // SHADERPASS_MARK_BEGIN
};

#define GLSTATE_MASK		( GLSTATE_MARK_END-1 )

// #define SHADERPASS_SRCBLEND_MASK (((GLSTATE_SRCBLEND_DST_ALPHA)<<1)-GLSTATE_SRCBLEND_ZERO)
#define GLSTATE_SRCBLEND_MASK		0xF

// #define SHADERPASS_DSTBLEND_MASK (((GLSTATE_DSTBLEND_DST_ALPHA)<<1)-GLSTATE_DSTBLEND_ZERO)
#define GLSTATE_DSTBLEND_MASK		0xF0

#define GLSTATE_BLENDFUNC		( GLSTATE_SRCBLEND_MASK|GLSTATE_DSTBLEND_MASK )
#define GLSTATE_ALPHAFUNC		( GLSTATE_AFUNC_GT0|GLSTATE_AFUNC_LT128|GLSTATE_AFUNC_GE128 )

typedef struct gltexture_s
{
	char		name[64];		// game path, including extension
	word		srcWidth;		// keep unscaled sizes
	word		srcHeight;
	word		width;		// upload width\height
	word		height;

	GLuint		target;		// glTarget
	GLuint		texnum;		// gl texture binding
	GLint		format;		// uploaded format
	texFlags_t	flags;

	// debug info
	byte		texType;		// used for gl_showtextures
	size_t		size;		// upload size for debug targets

	struct gltexture_s	*nextHash;
} gltexture_t;

// surface extradata stored in cache.data for all brushmodels
typedef struct mextrasurf_s
{
	vec3_t		mins, maxs;
	vec3_t		origin;		// surface origin
	int		checkcount;	// for multi-check avoidance
} mextrasurf_t;

typedef struct
{
	int		params;		// rendering parameters
	int		rdflags;		// actual rendering flags

	qboolean		drawWorld;	// ignore world for drawing PlayerModel
	qboolean		thirdPerson;	// thirdperson camera is enabled
	float		lerpFrac;		// lerpfraction

	ref_params_t	refdef;		// actual refdef

	cl_entity_t	*currententity;
	model_t		*currentmodel;

	int		viewport[4];
	int		scissor[4];
	mplane_t		frustum[6];

	vec3_t		pvsorigin;
	vec3_t		cullorigin;
	vec3_t		vieworg;		// locked vieworigin
	vec3_t		vforward;
	vec3_t		vright;
	vec3_t		vup;

	float		farClip;
	uint		clipFlags;

	float		waveHeight;	// global waveHeight
	float		currentWaveHeight;	// current entity waveHeight

	vec3_t		visMins, visMaxs;
	float		skyMins[2][6];
	float		skyMaxs[2][6];

	matrix4x4		objectMatrix;
	matrix4x4		worldviewMatrix;
	matrix4x4		modelviewMatrix;		// worldviewMatrix * objectMatrix

	matrix4x4		projectionMatrix;
	matrix4x4		worldviewProjectionMatrix;	// worldviewMatrix * projectionMatrix
	int		lightstylevalue[MAX_LIGHTSTYLES];	// value 0 - 65536
	float		lightstylecolor[MAX_LIGHTSTYLES];	// color 0 - 1.0

	mplane_t		clipPlane;
} ref_instance_t;

typedef struct
{
	int		cinTexture;      	// cinematic texture
	int		skyTexture;	// default sky texture
	int		whiteTexture;
	int		blackTexture;
	int		defaultTexture;   	// use for bad textures
	int		particleTexture;	// particle texture
	int		solidskyTexture;	// quake1 solid-sky layer
	int		alphaskyTexture;	// quake1 alpha-sky layer
	int		lightmapTextures[MAX_LIGHTMAPS];
	int		skyboxTextures[6];	// skybox sides

	int		skytexturenum;	// this not a gl_texturenum!

	// entity lists
	cl_entity_t	*static_entities[MAX_VISIBLE_PACKET];	// opaque non-moved brushes
	cl_entity_t	*solid_entities[MAX_VISIBLE_PACKET];	// opaque moving or alpha brushes
	cl_entity_t	*trans_entities[MAX_VISIBLE_PACKET];	// translucent brushes
	uint		num_static_entities;
	uint		num_solid_entities;
	uint		num_trans_entities;

	uint		numColors;	// vertex array num colors
	uint		numVertex;	// vertex array num vertex
	rgb_t		colorsArray[4096];	// MAXSTUDIOVERTS
	vec3_t		normalArray[4096];
	vec3_t		vertexArray[4096];
          
	// OpenGL matrix states
	qboolean		modelviewIdentity;
	
	int		visframecount;	// PVS frame
	int		dlightframecount;	// dynamic light frame
	int		framecount;
} ref_globals_t;

typedef struct
{
	uint		c_world_polys;
	uint		c_brush_polys;
	uint		c_studio_polys;
	uint		c_sprite_polys;
	uint		c_world_leafs;

	uint		c_view_beams_count;
	uint		c_active_tents_count;
	uint		c_studio_models_drawn;
	uint		c_sprite_models_drawn;
} ref_speeds_t;

extern ref_speeds_t		r_stats;
extern ref_params_t		r_lastRefdef;
extern ref_instance_t	RI;
extern ref_globals_t	tr;

extern float		gldepthmin, gldepthmax;
extern mleaf_t		*r_viewleaf, *r_oldviewleaf;
extern mleaf_t		*r_viewleaf2, *r_oldviewleaf2;
extern dlight_t		cl_dlights[MAX_DLIGHTS];
extern dlight_t		cl_elights[MAX_ELIGHTS];
#define r_numEntities	(tr.num_solid_entities + tr.num_trans_entities)
#define r_numStatics	(tr.num_static_entities)

//
// gl_backend.c
//
void GL_BackendStartFrame( void );
void GL_BackendEndFrame( void );
void GL_CleanUpTextureUnits( int last );
void GL_Bind( GLenum tmu, GLenum texnum );
void GL_MultiTexCoord2f( GLenum texture, GLfloat s, GLfloat t );
void GL_LoadTexMatrix( const matrix4x4 m );
void GL_LoadMatrix( const matrix4x4 source );
void GL_TexGen( GLenum coord, GLenum mode );
void GL_SelectTexture( GLenum texture );
void GL_LoadIdentityTexMatrix( void );
void GL_SetRenderMode( int mode );
void GL_FrontFace( GLenum front );
void GL_SetState( int state );
void GL_TexEnv( GLenum mode );
void GL_Cull( GLenum cull );
void R_ShowTextures( void );

//
// gl_cull.c
//
int R_CullModel( cl_entity_t *e, vec3_t mins, vec3_t maxs, float radius );
qboolean R_CullBox( const vec3_t mins, const vec3_t maxs, uint clipflags );
qboolean R_CullSphere( const vec3_t centre, const float radius, const uint clipflags );
qboolean R_VisCullBox( const vec3_t mins, const vec3_t maxs );
qboolean R_VisCullSphere( const vec3_t origin, float radius );

//
// gl_decals.c
//
void R_InitDecals( void );
void R_ShutdownDecals( void );
void DrawSurfaceDecals( msurface_t *fa );
void R_ClearDecals( void );

//
// gl_draw.c
//
void R_Set2DMode( qboolean enable );

//
// gl_image.c
//
void R_SetTextureParameters( void );
gltexture_t *R_GetTexture( GLenum texnum );
void GL_SetTextureType( GLenum texnum, GLenum type );
int GL_LoadTexture( const char *name, const byte *buf, size_t size, int flags );
int GL_LoadTextureInternal( const char *name, rgbdata_t *pic, texFlags_t flags, qboolean update );
byte *GL_ResampleTexture( const byte *source, int in_w, int in_h, int out_w, int out_h, qboolean isNormalMap );
void GL_FreeTexture( GLenum texnum );
void GL_FreeImage( const char *name );
void R_TextureList_f( void );
void R_InitImages( void );
void R_ShutdownImages( void );

//
// gl_refrag.c
//
void R_StoreEfrags( efrag_t **ppefrag );

//
// gl_rlight.c
//
void R_PushDlights( void );
void R_AnimateLight( void );
void R_MarkLights( dlight_t *light, int bit, mnode_t *node );
void R_LightDir( const vec3_t origin, vec3_t lightDir, float radius );
void R_LightForPoint( const vec3_t point, color24 *ambientLight, qboolean invLight, float radius );
void R_LightForOrigin( const vec3_t origin, vec3_t dir, color24 *ambient, color24 *diffuse, float radius );

//
// gl_rmain.c
//
void R_ClearScene( void );
void R_LoadIdentity( void );
void R_DrawCubemapView( const vec3_t origin, const vec3_t angles, int size );
qboolean R_WorldToScreen2( const vec3_t in, vec3_t out );
void R_TranslateForEntity( cl_entity_t *e );
void R_RotateForEntity( cl_entity_t *e );

//
// gl_rmath.c
//
void R_InitMathlib( void );
void R_LatLongToNorm( const byte latlong[2], vec3_t normal );
void R_NormToLatLong( const vec3_t normal, byte latlong[2] );
float V_CalcFov( float *fov_x, float width, float height );
void V_AdjustFov( float *fov_x, float *fov_y, float width, float height, qboolean lock_x );
byte R_FloatToByte( float x );
void Matrix4x4_ToArrayFloatGL( const matrix4x4 in, float out[16] );
void Matrix4x4_FromArrayFloatGL( matrix4x4 out, const float in[16] );
void Matrix4x4_Concat( matrix4x4 out, const matrix4x4 in1, const matrix4x4 in2 );
void Matrix4x4_ConcatTranslate( matrix4x4 out, float x, float y, float z );
void Matrix4x4_ConcatRotate( matrix4x4 out, float angle, float x, float y, float z );
void Matrix4x4_CreateTranslate( matrix4x4 out, float x, float y, float z );
void Matrix4x4_CreateRotate( matrix4x4 out, float angle, float x, float y, float z );
void Matrix4x4_CreateProjection(matrix4x4 out, float xMax, float xMin, float yMax, float yMin, float zNear, float zFar);
void Matrix4x4_CreateModelview( matrix4x4 out );


//
// gl_rsurf.c
//
void R_MarkLeaves( void );
void R_DrawWorld( void );
void R_DrawWaterSurfaces( void );
void R_DrawBrushModel( cl_entity_t *e );
void GL_SubdivideSurface( msurface_t *fa );
void GL_BuildPolygonFromSurface( msurface_t *fa );
void GL_BuildLightmaps( void );

//
// gl_sprite.c
//
void R_SpriteInit( void );
void Mod_LoadSpriteModel( model_t *mod, const void *buffer );
mspriteframe_t *R_GetSpriteFrame( const model_t *pModel, int frame, float yaw );
void R_DrawSpriteModel( cl_entity_t *e );

//
// gl_studio.c
//
void R_StudioInit( void );
void Mod_LoadStudioModel( model_t *mod, const void *buffer );
void R_DrawStudioModel( cl_entity_t *e );

//
// gl_warp.c
//
void R_InitSky( struct mip_s *mt, struct texture_s *tx );
void R_AddSkyBoxSurface( msurface_t *fa );
void R_ClearSkyBox( void );
void R_DrawSkyBox( void );
void EmitSkyLayers( msurface_t *fa );
void EmitSkyPolys( msurface_t *fa );
void EmitWaterPolys( glpoly_t *polys );
void R_DrawSkyChain( msurface_t *s );

//
// gl_vidnt.c
//
#define GL_CheckForErrors() GL_CheckForErrors_( __FILE__, __LINE__ )
void GL_CheckForErrors_( const char *filename, const int fileline );
void GL_UpdateSwapInterval( void );
void GL_UpdateGammaRamp( void );
qboolean GL_DeleteContext( void );
qboolean GL_Support( int r_ext );
void VID_CheckChanges( void );
qboolean R_Init( void );
void R_Shutdown( void );

/*
=======================================================================

 GL STATE MACHINE

=======================================================================
*/
enum
{
	GL_OPENGL_110 = 0,		// base
	GL_WGL_SWAPCONTROL,		
	GL_HARDWARE_GAMMA_CONTROL,
	GL_ARB_VERTEX_BUFFER_OBJECT_EXT,
	GL_ENV_COMBINE_EXT,
	GL_ARB_MULTITEXTURE,
	GL_TEXTURECUBEMAP_EXT,
	GL_DOT3_ARB_EXT,
	GL_ANISOTROPY_EXT,
	GL_TEXTURE_LODBIAS,
	GL_OCCLUSION_QUERIES_EXT,
	GL_TEXTURE_COMPRESSION_EXT,
	GL_SHADER_GLSL100_EXT,
	GL_WGL_3DFX_GAMMA_CONTROL,
	GL_SGIS_MIPMAPS_EXT,
	GL_DRAW_RANGEELEMENTS_EXT,
	GL_LOCKARRAYS_EXT,
	GL_TEXTURE_3D_EXT,
	GL_CLAMPTOEDGE_EXT,
	GL_BLEND_MINMAX_EXT,
	GL_STENCILTWOSIDE_EXT,
	GL_BLEND_SUBTRACT_EXT,
	GL_SHADER_OBJECTS_EXT,
	GL_VERTEX_SHADER_EXT,	// glsl vertex program
	GL_FRAGMENT_SHADER_EXT,	// glsl fragment program	
	GL_EXT_POINTPARAMETERS,
	GL_SEPARATESTENCIL_EXT,
	GL_ARB_TEXTURE_NPOT_EXT,
	GL_CUSTOM_VERTEX_ARRAY_EXT,
	GL_TEXTURE_ENV_ADD_EXT,
	GL_CLAMP_TEXBORDER_EXT,
	GL_DEPTH_TEXTURE,
	GL_SHADOW_EXT,
	GL_EXTCOUNT,		// must be last
};

enum
{
	GL_TEXTURE0 = 0,
	GL_TEXTURE1,
	GL_TEXTURE2,
	GL_TEXTURE3,		// g-cont. 4 units should be enough
	MAX_TEXTURE_UNITS		// must be last
};

typedef struct
{
	const char	*renderer_string;		// ptrs to OpenGL32.dll, use with caution
	const char	*vendor_string;
	const char	*version_string;

	// list of supported extensions
	const char	*extensions_string;
	byte		extension[GL_EXTCOUNT];

	int		max_texture_units;
	GLint		max_2d_texture_size;
	GLint		max_2d_rectangle_size;
	GLint		max_3d_texture_size;
	GLint		max_cubemap_size;
	GLint		texRectangle;

	GLfloat		max_texture_anisotropy;
	GLfloat		max_texture_lodbias;

	int		color_bits;
	int		alpha_bits;
	int		depth_bits;
	int		stencil_bits;

	qboolean		deviceSupportsGamma;
	int		prev_mode;
} glconfig_t;

typedef struct
{
	int		flags;

	word		gammaRamp[768];		// current gamma ramp
	word		stateRamp[768];		// original gamma ramp

	int		width, height;
	qboolean		fullScreen;
	qboolean		wideScreen;

	qboolean		initializedMedia;

	int		activeTMU;
	GLuint		currentTextures[MAX_TEXTURE_UNITS];
	GLenum		currentEnvModes[MAX_TEXTURE_UNITS];
	GLboolean		texIdentityMatrix[MAX_TEXTURE_UNITS];
	GLint		genSTEnabled[MAX_TEXTURE_UNITS];	// 0 - disabled, OR 1 - S, OR 2 - T, OR 4 - R
	GLint		texCoordArrayMode[MAX_TEXTURE_UNITS];	// 0 - disabled, 1 - enabled, 2 - cubemap

	int		faceCull;
	int		frontFace;

	qboolean		stencilEnabled;
	qboolean		in2DMode;
} glstate_t;

typedef struct
{
	HDC		hDC;		// handle to device context
	HGLRC		hGLRC;		// handle to GL rendering context

	int		desktopBitsPixel;
	int		desktopWidth;
	int		desktopHeight;

	qboolean		software;		// OpenGL software emulation
	qboolean		initialized;	// OpenGL subsystem started
	qboolean		minidriver;	// 3dfx driver
} glwstate_t;

extern glconfig_t		glConfig;
extern glstate_t		glState;
extern glwstate_t		glw_state;

//
// renderer cvars
//
extern convar_t	*gl_allow_software;
extern convar_t	*gl_texture_anisotropy;
extern convar_t	*gl_extensions;
extern convar_t	*gl_stencilbits;
extern convar_t	*gl_texturebits;
extern convar_t	*gl_ignorehwgamma;
extern convar_t	*gl_swapInterval;
extern convar_t	*gl_check_errors;
extern convar_t	*gl_round_down;
extern convar_t	*gl_texturemode;
extern convar_t	*gl_texture_lodbias;
extern convar_t	*gl_showtextures;
extern convar_t	*gl_compress_textures;
extern convar_t	*gl_allow_static;
extern convar_t	*gl_picmip;
extern convar_t	*gl_skymip;
extern convar_t	*gl_nobind;
extern convar_t	*gl_finish;
extern convar_t	*gl_clear;
extern convar_t	*gl_test;		// cvar to testify new effects

extern convar_t	*r_width;
extern convar_t	*r_height;
extern convar_t	*r_speeds;
extern convar_t	*r_fullbright;
extern convar_t	*r_norefresh;
extern convar_t	*r_lighting_modulate;
extern convar_t	*r_lighting_ambient;
extern convar_t	*r_lighting_direct;
extern convar_t	*r_faceplanecull;
extern convar_t	*r_drawentities;
extern convar_t	*r_adjust_fov;
extern convar_t	*r_lefthand;
extern convar_t	*r_decals;
extern convar_t	*r_novis;
extern convar_t	*r_nocull;
extern convar_t	*r_lockpvs;
extern convar_t	*r_lockcull;
extern convar_t	*r_wateralpha;
extern convar_t	*r_dynamic;
extern convar_t	*r_lightmap;
extern convar_t	*r_shadows;
extern convar_t	*r_fastsky;

extern convar_t	*vid_displayfrequency;
extern convar_t	*vid_fullscreen;
extern convar_t	*vid_gamma;
extern convar_t	*vid_mode;

#endif//GL_LOCAL_H