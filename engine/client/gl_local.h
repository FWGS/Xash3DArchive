//=======================================================================
//			Copyright XashXT Group 2010 ©
//		     gl_local.h - renderer local declarations
//=======================================================================

#ifndef GL_LOCAL_H
#define GL_LOCAL_H

#include "gl_export.h"
#include "com_model.h"
#include "cl_entity.h"

extern byte	*r_temppool;

#define MAX_TEXTURES	1024
#define MAX_LIGHTMAPS	128

#define RP_NONE		0
#define RP_MIRRORVIEW	BIT( 0 )	// lock pvs at vieworg
#define RP_PORTALVIEW	BIT( 1 )
#define RP_ENVVIEW		BIT( 2 )	// used for cubemapshot

typedef enum
{
	TEX_INVALID = 0,	// free slot
	TEX_SYSTEM,	// generated by engine
	TEX_NOMIP,	// hud pics, menu etc
	TEX_BRUSH,	// a map texture
	TEX_SPRITE,	// sprite frames
	TEX_STUDIO,	// studio skins
	TEX_LIGHTMAP,	// lightmap textures
	TEX_CUBEMAP	// cubemap textures
} texType_t;

typedef enum
{
	TF_STATIC		= BIT(0),		// don't free until Shader_FreeUnused()
	TF_NOPICMIP	= BIT(1),		// ignore r_picmip resample rules
	TF_UNCOMPRESSED	= BIT(2),		// don't compress texture in video memory
	TF_CUBEMAP	= BIT(3),		// it's cubemap texture
	TF_DEPTHMAP	= BIT(4),		// custom texture filter used
	TF_INTENSITY	= BIT(5),
	TF_ALPHA		= BIT(6),
	TF_SKYSIDE	= BIT(7),
	TF_CLAMP		= BIT(8),
	TF_NOMIPMAP	= BIT(9),
	TF_NEAREST	= BIT(10),	// disable texfilter
	TF_LIGHTMAP	= BIT(11),	// no resample etc
	TF_HAS_LUMA	= BIT(12),	// sets by GL_UploadTexture
	TF_MAKELUMA	= BIT(13),	// create luma from quake texture
	TF_NORMALMAP	= BIT(14),	// is a normalmap
} texFlags_t;

typedef struct gltexture_s
{
	char		name[64];		// game path, including extension
	word		srcWidth;		// keep unscaled sizes
	word		srcHeight;
	word		width;		// upload width\height
	word		height;

	GLuint		target;		// glTarget
	GLuint		texnum;		// gl texture binding
	GLint		format;		// uploaded format
	texFlags_t	flags;

	// debug info
	texType_t		texType;		// used for gl_showtextures
	size_t		size;		// upload size for debug targets

	struct gltexture_s	*nextHash;
} gltexture_t;

typedef struct
{
	int		params;		// rendering parameters
	qboolean		drawWorld;	// ignore world for drawing PlayerModel
	qboolean		thirdPerson;	// thirdperson camera is enabled

	cl_entity_t	*currententity;
	model_t		*currentmodel;
} ref_instance_t;

typedef struct
{
	int		cinTexture;      	// cinematic texture
	int		skyTexture;	// default sky texture
	int		whiteTexture;
	int		blackTexture;
	int		defaultTexture;   	// use for bad textures
	int		particleTexture;	// particle texture
	int		lightmapTextures[MAX_LIGHTMAPS];
} ref_globals_t;

extern ref_params_t		r_lastRefdef;
extern ref_instance_t	RI;
extern ref_globals_t	tr;

void GL_SubdivideSurface( msurface_t *fa );
void GL_BuildPolygonFromSurface( msurface_t *fa );

//
// gl_backend.c
//
void GL_Bind( GLenum tmu, GLenum texnum );
void GL_TexGen( GLenum coord, GLenum mode );
void GL_SelectTexture( GLenum texture );
void GL_FrontFace( GLenum front );
void GL_TexEnv( GLenum mode );
void GL_Cull( GLenum cull );

//
// gl_draw.c
//
void R_Set2DMode( qboolean enable );

//
// gl_image.c
//
void R_SetTextureParameters( void );
gltexture_t *R_GetTexture( GLenum texnum );
int GL_LoadTexture( const char *name, const byte *buf, size_t size, int flags );
int GL_LoadTextureInternal( const char *name, rgbdata_t *pic, texFlags_t flags, qboolean subImage );
byte *GL_ResampleTexture( const byte *source, int inWidth, int inHeight, int outWidth, int outHeight, qboolean isNormalMap );
void GL_FreeTexture( GLenum texnum );
void GL_FreeImage( const char *name );
void R_InitImages( void );
void R_ShutdownImages( void );

//
// gl_rmain.c
//
void R_ClearScene( void );
void R_DrawCubemapView( const vec3_t origin, const vec3_t angles, int size );

//
// gl_vidnt.c
//
#define GL_CheckForErrors() GL_CheckForErrors_( __FILE__, __LINE__ )
void GL_CheckForErrors_( const char *filename, const int fileline );
void GL_UpdateSwapInterval( void );
void GL_UpdateGammaRamp( void );
qboolean GL_Support( int r_ext );
qboolean R_Init( void );
void R_Shutdown( void );

/*
=======================================================================

 GL STATE MACHINE

=======================================================================
*/
enum
{
	GL_OPENGL_110 = 0,		// base
	GL_WGL_SWAPCONTROL,		
	GL_HARDWARE_GAMMA_CONTROL,
	GL_ARB_VERTEX_BUFFER_OBJECT_EXT,
	GL_ENV_COMBINE_EXT,
	GL_ARB_MULTITEXTURE,
	GL_TEXTURECUBEMAP_EXT,
	GL_DOT3_ARB_EXT,
	GL_ANISOTROPY_EXT,
	GL_TEXTURE_LODBIAS,
	GL_OCCLUSION_QUERIES_EXT,
	GL_TEXTURE_COMPRESSION_EXT,
	GL_SHADER_GLSL100_EXT,
	GL_WGL_3DFX_GAMMA_CONTROL,
	GL_SGIS_MIPMAPS_EXT,
	GL_DRAW_RANGEELEMENTS_EXT,
	GL_LOCKARRAYS_EXT,
	GL_TEXTURE_3D_EXT,
	GL_CLAMPTOEDGE_EXT,
	GL_BLEND_MINMAX_EXT,
	GL_STENCILTWOSIDE_EXT,
	GL_BLEND_SUBTRACT_EXT,
	GL_SHADER_OBJECTS_EXT,
	GL_VERTEX_SHADER_EXT,	// glsl vertex program
	GL_FRAGMENT_SHADER_EXT,	// glsl fragment program	
	GL_EXT_POINTPARAMETERS,
	GL_SEPARATESTENCIL_EXT,
	GL_ARB_TEXTURE_NPOT_EXT,
	GL_CUSTOM_VERTEX_ARRAY_EXT,
	GL_TEXTURE_ENV_ADD_EXT,
	GL_CLAMP_TEXBORDER_EXT,
	GL_DEPTH_TEXTURE,
	GL_SHADOW_EXT,
	GL_EXTCOUNT,		// must be last
};

enum
{
	GL_TEXTURE0 = 0,
	GL_TEXTURE1,
	GL_TEXTURE2,
	GL_TEXTURE3,		// g-cont. 4 units should be enough
	MAX_TEXTURE_UNITS		// must be last
};

typedef struct
{
	const char	*renderer_string;		// ptrs to OpenGL32.dll, use with caution
	const char	*vendor_string;
	const char	*version_string;

	// list of supported extensions
	const char	*extensions_string;
	byte		extension[GL_EXTCOUNT];

	int		max_texture_units;
	GLint		max_2d_texture_size;
	GLint		max_2d_rectangle_size;
	GLint		max_3d_texture_size;
	GLint		max_cubemap_size;
	GLint		texRectangle;

	GLfloat		max_texture_anisotropy;
	GLfloat		max_texture_lodbias;

	int		color_bits;
	int		depth_bits;
	int		stencil_bits;

	qboolean		deviceSupportsGamma;
	int		prev_mode;
} glconfig_t;

typedef struct
{
	int		flags;

	word		gammaRamp[768];		// current gamma ramp
	word		stateRamp[768];		// original gamma ramp

	int		width, height;
	qboolean		fullScreen;
	qboolean		wideScreen;

	qboolean		initializedMedia;

	int		activeTMU;
	GLuint		currentTextures[MAX_TEXTURE_UNITS];
	GLenum		currentEnvModes[MAX_TEXTURE_UNITS];
	GLboolean		texIdentityMatrix[MAX_TEXTURE_UNITS];
	GLint		genSTEnabled[MAX_TEXTURE_UNITS];	// 0 - disabled, OR 1 - S, OR 2 - T, OR 4 - R
	GLint		texCoordArrayMode[MAX_TEXTURE_UNITS];	// 0 - disabled, 1 - enabled, 2 - cubemap

	rgba_t		draw_color;
	int		draw_rendermode;			// rendermode for drawing
	int		draw_frame;			// will be reset after each drawing

	int		faceCull;
	int		frontFace;

	qboolean		stencilEnabled;
	qboolean		in2DMode;
} glstate_t;

typedef struct
{
	HDC		hDC;		// handle to device context
	HGLRC		hGLRC;		// handle to GL rendering context

	int		desktopBitsPixel;
	int		desktopWidth;
	int		desktopHeight;

	qboolean		software;		// OpenGL software emulation
	qboolean		initialized;	// OpenGL subsystem started
	qboolean		minidriver;	// 3dfx driver
} glwstate_t;

extern glconfig_t		glConfig;
extern glstate_t		glState;
extern glwstate_t		glw_state;

//
// renderer cvars
//
extern convar_t	*gl_allow_software;
extern convar_t	*gl_texture_anisotropy;
extern convar_t	*gl_extensions;
extern convar_t	*gl_colorbits;
extern convar_t	*gl_depthbits;
extern convar_t	*gl_stencilbits;
extern convar_t	*gl_texturebits;
extern convar_t	*gl_ignorehwgamma;
extern convar_t	*gl_swapInterval;
extern convar_t	*gl_check_errors;
extern convar_t	*gl_round_down;
extern convar_t	*gl_texturemode;
extern convar_t	*gl_texture_lodbias;
extern convar_t	*gl_showtextures;
extern convar_t	*gl_compress_textures;
extern convar_t	*gl_picmip;
extern convar_t	*gl_skymip;
extern convar_t	*gl_nobind;
extern convar_t	*gl_finish;
extern convar_t	*gl_delayfinish;
extern convar_t	*gl_frontbuffer;
extern convar_t	*gl_clear;

extern convar_t	*r_width;
extern convar_t	*r_height;

extern convar_t	*vid_displayfrequency;
extern convar_t	*vid_fullscreen;
extern convar_t	*vid_gamma;
extern convar_t	*vid_mode;

#endif//GL_LOCAL_H